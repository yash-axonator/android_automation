"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_util_1 = __importDefault(require("node:util"));
const logger_1 = __importDefault(require("@wdio/logger"));
const util_1 = require("./util");
const accessibility_scripts_1 = __importDefault(require("./scripts/accessibility-scripts"));
const log = (0, logger_1.default)('@wdio/browserstack-service');
class _AccessibilityHandler {
    constructor(_browser, _capabilities, isAppAutomate, _framework, _accessibilityAutomation, _accessibilityOpts) {
        this._browser = _browser;
        this._capabilities = _capabilities;
        this._framework = _framework;
        this._accessibilityAutomation = _accessibilityAutomation;
        this._accessibilityOpts = _accessibilityOpts;
        this._testMetadata = {};
        this._sessionId = null;
        const caps = this._browser.capabilities;
        this._platformA11yMeta = {
            browser_name: caps.browserName,
            browser_version: (caps === null || caps === void 0 ? void 0 : caps.browserVersion) || (caps === null || caps === void 0 ? void 0 : caps.version) || 'latest',
            os_name: this._getCapabilityValue(_capabilities, 'os', 'os'),
            os_version: this._getCapabilityValue(_capabilities, 'osVersion', 'os_version')
        };
        this._caps = _capabilities;
        this._accessibility = (0, util_1.isTrue)(_accessibilityAutomation);
        this._accessibilityOptions = _accessibilityOpts;
    }
    setSuiteFile(filename) {
        this._suiteFile = filename;
    }
    _getCapabilityValue(caps, capType, legacyCapType) {
        var _a, _b, _c, _d, _e, _f;
        if (caps) {
            if (capType === 'accessibility') {
                if (caps['bstack:options'] && ((0, util_1.isTrue)((_a = caps['bstack:options']) === null || _a === void 0 ? void 0 : _a.accessibility))) {
                    return (_b = caps['bstack:options']) === null || _b === void 0 ? void 0 : _b.accessibility;
                }
                else if ((0, util_1.isTrue)(caps['browserstack.accessibility'])) {
                    return caps['browserstack.accessibility'];
                }
            }
            else if (capType === 'deviceName') {
                if (caps['bstack:options'] && ((_c = caps['bstack:options']) === null || _c === void 0 ? void 0 : _c.deviceName)) {
                    return (_d = caps['bstack:options']) === null || _d === void 0 ? void 0 : _d.deviceName;
                }
                else if (caps['bstack:options'] && ((_e = caps['bstack:options']) === null || _e === void 0 ? void 0 : _e.device)) {
                    return (_f = caps['bstack:options']) === null || _f === void 0 ? void 0 : _f.device;
                }
                else if (caps['appium:deviceName']) {
                    return caps['appium:deviceName'];
                }
            }
            else if (capType === 'goog:chromeOptions' && caps['goog:chromeOptions']) {
                return caps['goog:chromeOptions'];
            }
            else {
                const bstackOptions = caps['bstack:options'];
                if (bstackOptions && (bstackOptions === null || bstackOptions === void 0 ? void 0 : bstackOptions[capType])) {
                    return bstackOptions === null || bstackOptions === void 0 ? void 0 : bstackOptions[capType];
                }
                else if (caps[legacyCapType]) {
                    return caps[legacyCapType];
                }
            }
        }
    }
    async before(sessionId) {
        this._sessionId = sessionId;
        this._accessibility = (0, util_1.isTrue)(this._getCapabilityValue(this._caps, 'accessibility', 'browserstack.accessibility'));
        if ((0, util_1.isBrowserstackSession)(this._browser) && (0, util_1.isAccessibilityAutomationSession)(this._accessibility)) {
            const deviceName = this._getCapabilityValue(this._caps, 'deviceName', 'device');
            const chromeOptions = this._getCapabilityValue(this._caps, 'goog:chromeOptions', '');
            this._accessibility = (0, util_1.validateCapsWithA11y)(deviceName, this._platformA11yMeta, chromeOptions);
        }
        this._browser.getAccessibilityResultsSummary = async () => {
            return await (0, util_1.getA11yResultsSummary)(this._browser, (0, util_1.isBrowserstackSession)(this._browser), this._accessibility);
        };
        this._browser.getAccessibilityResults = async () => {
            return await (0, util_1.getA11yResults)(this._browser, (0, util_1.isBrowserstackSession)(this._browser), this._accessibility);
        };
        this._browser.performScan = async () => {
            return await (0, util_1.performA11yScan)(this._browser, (0, util_1.isBrowserstackSession)(this._browser), this._accessibility);
        };
        if (!this._accessibility) {
            return;
        }
        if (!('overwriteCommand' in this._browser && Array.isArray(accessibility_scripts_1.default.commandsToWrap))) {
            return;
        }
        accessibility_scripts_1.default.commandsToWrap
            .filter((command) => (command.name && command.class))
            .forEach((command) => {
            var _a;
            try {
                (_a = this._browser) === null || _a === void 0 ? void 0 : _a.overwriteCommand(command.name, this.commandWrapper.bind(this, command), command.class === 'Element');
            }
            catch (er) {
                log.debug(`Unable to overwrite command ${node_util_1.default.format(command)} ${node_util_1.default.format(er)}`);
            }
        });
    }
    async beforeTest(suiteTitle, test) {
        if (this._framework !== 'mocha' ||
            !this.shouldRunTestHooks(this._browser, this._accessibility)) {
            return;
        }
        const shouldScanTest = (0, util_1.shouldScanTestForAccessibility)(suiteTitle, test.title, this._accessibilityOptions);
        const testIdentifier = this.getIdentifier(test);
        if (this._sessionId) {
            /* For case with multiple tests under one browser, before hook of 2nd test should change this map value */
            AccessibilityHandler._a11yScanSessionMap[this._sessionId] = shouldScanTest;
        }
        try {
            const isPageOpened = await this.checkIfPageOpened(this._browser, testIdentifier, shouldScanTest);
            if (!isPageOpened) {
                return;
            }
            this._testMetadata[testIdentifier].accessibilityScanStarted = shouldScanTest;
            if (shouldScanTest) {
                log.info('Automate test case execution has started.');
            }
        }
        catch (error) {
            log.error(`Exception in starting accessibility automation scan for this test case ${error}`);
        }
    }
    async afterTest(suiteTitle, test) {
        var _a, _b;
        if (this._framework !== 'mocha' ||
            !this.shouldRunTestHooks(this._browser, this._accessibility)) {
            return;
        }
        try {
            const testIdentifier = this.getIdentifier(test);
            const accessibilityScanStarted = (_a = this._testMetadata[testIdentifier]) === null || _a === void 0 ? void 0 : _a.accessibilityScanStarted;
            const shouldScanTestForAccessibility = (_b = this._testMetadata[testIdentifier]) === null || _b === void 0 ? void 0 : _b.scanTestForAccessibility;
            if (!accessibilityScanStarted) {
                return;
            }
            if (shouldScanTestForAccessibility) {
                log.info('Automate test case execution has ended. Processing for accessibility testing is underway. ');
            }
            const dataForExtension = {
                saveResults: shouldScanTestForAccessibility,
                testDetails: {
                    'name': test.title,
                    'testRunId': process.env.BS_A11Y_TEST_RUN_ID,
                    'filePath': this._suiteFile,
                    'scopeList': [suiteTitle, test.title]
                },
                platform: this._platformA11yMeta
            };
            await this.sendTestStopEvent(this._browser, dataForExtension);
            if (shouldScanTestForAccessibility) {
                log.info('Accessibility testing for this test case has ended.');
            }
        }
        catch (error) {
            log.error(`Accessibility results could not be processed for the test case ${test.title}. Error :`, error);
        }
    }
    /**
      * Cucumber Only
    */
    async beforeScenario(world) {
        const pickleData = world.pickle;
        const gherkinDocument = world.gherkinDocument;
        const featureData = gherkinDocument.feature;
        const uniqueId = (0, util_1.getUniqueIdentifierForCucumber)(world);
        if (!this.shouldRunTestHooks(this._browser, this._accessibility)) {
            return;
        }
        try {
            const shouldScanScenario = (0, util_1.shouldScanTestForAccessibility)(featureData === null || featureData === void 0 ? void 0 : featureData.name, pickleData.name, this._accessibilityOptions);
            const isPageOpened = await this.checkIfPageOpened(this._browser, uniqueId, shouldScanScenario);
            this._testMetadata[uniqueId].accessibilityScanStarted = shouldScanScenario;
            if (this._sessionId) {
                /* For case with multiple tests under one browser, before hook of 2nd test should change this map value */
                AccessibilityHandler._a11yScanSessionMap[this._sessionId] = shouldScanScenario;
            }
            if (!isPageOpened) {
                return;
            }
            if (shouldScanScenario) {
                log.info('Automate test case execution has started.');
            }
        }
        catch (error) {
            log.error(`Exception in starting accessibility automation scan for this test case ${error}`);
        }
    }
    async afterScenario(world) {
        var _a, _b;
        if (!this.shouldRunTestHooks(this._browser, this._accessibility)) {
            return;
        }
        const pickleData = world.pickle;
        try {
            const gherkinDocument = world.gherkinDocument;
            const featureData = gherkinDocument.feature;
            const uniqueId = (0, util_1.getUniqueIdentifierForCucumber)(world);
            const accessibilityScanStarted = (_a = this._testMetadata[uniqueId]) === null || _a === void 0 ? void 0 : _a.accessibilityScanStarted;
            const shouldScanTestForAccessibility = (_b = this._testMetadata[uniqueId]) === null || _b === void 0 ? void 0 : _b.scanTestForAccessibility;
            if (!accessibilityScanStarted) {
                return;
            }
            if (shouldScanTestForAccessibility) {
                log.info('Automate test case execution has ended. Processing for accessibility testing is underway. ');
            }
            const dataForExtension = {
                saveResults: shouldScanTestForAccessibility,
                testDetails: {
                    'name': pickleData.name,
                    'testRunId': process.env.BS_A11Y_TEST_RUN_ID,
                    'filePath': gherkinDocument.uri,
                    'scopeList': [featureData === null || featureData === void 0 ? void 0 : featureData.name, pickleData.name]
                },
                platform: this._platformA11yMeta
            };
            await this.sendTestStopEvent(this._browser, dataForExtension);
            if (shouldScanTestForAccessibility) {
                log.info('Accessibility testing for this test case has ended.');
            }
        }
        catch (error) {
            log.error(`Accessibility results could not be processed for the test case ${pickleData.name}. Error :`, error);
        }
    }
    /*
     * private methods
     */
    async commandWrapper(command, origFunction, ...args) {
        if (this._sessionId && AccessibilityHandler._a11yScanSessionMap[this._sessionId] &&
            (!command.name.includes('execute') ||
                !AccessibilityHandler.shouldPatchExecuteScript(args.length ? args[0] : null))) {
            log.debug(`Performing scan for ${command.class} ${command.name}`);
            await (0, util_1.performA11yScan)(this._browser, true, true, command.name);
        }
        return origFunction(...args);
    }
    async sendTestStopEvent(browser, dataForExtension) {
        log.debug('Performing scan before saving results');
        await (0, util_1.performA11yScan)(browser, true, true);
        const results = await browser.executeAsync(accessibility_scripts_1.default.saveTestResults, dataForExtension);
        log.debug(node_util_1.default.format(results));
    }
    getIdentifier(test) {
        if ('pickle' in test) {
            return (0, util_1.getUniqueIdentifierForCucumber)(test);
        }
        return (0, util_1.getUniqueIdentifier)(test, this._framework);
    }
    shouldRunTestHooks(browser, isAccessibility) {
        if (!browser) {
            return false;
        }
        return (0, util_1.isBrowserstackSession)(browser) && (0, util_1.isAccessibilityAutomationSession)(isAccessibility);
    }
    async checkIfPageOpened(browser, testIdentifier, shouldScanTest) {
        let pageOpen = false;
        this._testMetadata[testIdentifier] = {
            scanTestForAccessibility: shouldScanTest,
            accessibilityScanStarted: true
        };
        try {
            const currentURL = await browser.getUrl();
            const url = new URL(currentURL);
            pageOpen = (url === null || url === void 0 ? void 0 : url.protocol) === 'http:' || (url === null || url === void 0 ? void 0 : url.protocol) === 'https:';
        }
        catch (e) {
            pageOpen = false;
        }
        return pageOpen;
    }
    static shouldPatchExecuteScript(script) {
        if (!script || typeof script !== 'string') {
            return true;
        }
        return (script.toLowerCase().indexOf('browserstack_executor') !== -1 ||
            script.toLowerCase().indexOf('browserstack_accessibility_automation_script') !== -1);
    }
}
_AccessibilityHandler._a11yScanSessionMap = {};
// https://github.com/microsoft/TypeScript/issues/6543
const AccessibilityHandler = (0, util_1.o11yClassErrorHandler)(_AccessibilityHandler);
exports.default = AccessibilityHandler;

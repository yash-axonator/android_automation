"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Transport = require("winston-transport");
const constants_js_1 = require("./constants.js");
const LOG_LEVELS = {
    INFO: 'INFO',
    ERROR: 'ERROR',
    DEBUG: 'DEBUG',
    TRACE: 'TRACE',
    WARN: 'WARN',
};
class logReportingAPI extends Transport {
    constructor() {
        super(...arguments);
        this.logToTestOps = (level = LOG_LEVELS.INFO, message = '', consoleLog = true) => {
            if (consoleLog) {
                constants_js_1.consoleHolder[level.toLowerCase()](message);
            }
            process.emit(`bs:addLog:${process.pid}`, {
                timestamp: new Date().toISOString(),
                level: level.toUpperCase(),
                message: message,
                kind: 'TEST_LOG',
                http_response: {}
            });
        };
        /* Patching this would show user an extended trace on their cli */
        this.trace = (message) => {
            this.logToTestOps(LOG_LEVELS.TRACE, message);
        };
        this.debug = (message) => {
            this.logToTestOps(LOG_LEVELS.DEBUG, message);
        };
        this.info = (message) => {
            this.logToTestOps(LOG_LEVELS.INFO, message);
        };
        this.warn = (message) => {
            this.logToTestOps(LOG_LEVELS.WARN, message);
        };
        this.error = (message) => {
            this.logToTestOps(LOG_LEVELS.ERROR, message);
        };
    }
    log(info, callback = undefined) {
        setImmediate(() => {
            this.emit('logged', info);
        });
        if (typeof (info) === 'object') {
            /* From log appender */
            this.logToTestOps(info.level || LOG_LEVELS.INFO, info.message, false);
        }
        else {
            /* From default console */
            this.logToTestOps(LOG_LEVELS.INFO, info);
        }
        if (callback && typeof callback === 'function') {
            callback();
        }
    }
}
exports.default = logReportingAPI;

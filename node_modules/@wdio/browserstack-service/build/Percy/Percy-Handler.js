"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const PercyCaptureMap_1 = __importDefault(require("./PercyCaptureMap"));
const PercySDK = __importStar(require("./PercySDK"));
const PercyLogger_1 = require("./PercyLogger");
const constants_1 = require("../constants");
class _PercyHandler {
    constructor(_percyAutoCaptureMode, _browser, _capabilities, isAppAutomate, _framework) {
        this._percyAutoCaptureMode = _percyAutoCaptureMode;
        this._browser = _browser;
        this._capabilities = _capabilities;
        this._framework = _framework;
        this._testMetadata = {};
        this._isPercyCleanupProcessingUnderway = false;
        this._percyScreenshotCounter = 0;
        this._percyDeferredScreenshots = [];
        this._percyScreenshotInterval = null;
        this._isAppAutomate = isAppAutomate;
        if (!_percyAutoCaptureMode || !constants_1.CAPTURE_MODES.includes(_percyAutoCaptureMode)) {
            this._percyAutoCaptureMode = 'auto';
        }
    }
    _setSessionName(name) {
        this._sessionName = name;
    }
    async teardown() {
        await new Promise((resolve) => {
            setInterval(() => {
                if (this._percyScreenshotCounter === 0) {
                    resolve();
                }
            }, 1000);
        });
    }
    async percyAutoCapture(eventName, sessionName) {
        var _a, _b, _c, _d;
        try {
            if (eventName) {
                if (!sessionName) {
                    /* Service doesn't wait for handling of browser commands so the below counter is used in teardown method to delay service exit */
                    this._percyScreenshotCounter += 1;
                }
                (_a = this._percyCaptureMap) === null || _a === void 0 ? void 0 : _a.increment(sessionName ? sessionName : this._sessionName, eventName);
                await (this._isAppAutomate ? PercySDK.screenshotApp((_b = this._percyCaptureMap) === null || _b === void 0 ? void 0 : _b.getName(sessionName ? sessionName : this._sessionName, eventName)) : PercySDK.screenshot(this._browser, (_c = this._percyCaptureMap) === null || _c === void 0 ? void 0 : _c.getName(sessionName ? sessionName : this._sessionName, eventName)));
                this._percyScreenshotCounter -= 1;
            }
        }
        catch (err) {
            this._percyScreenshotCounter -= 1;
            (_d = this._percyCaptureMap) === null || _d === void 0 ? void 0 : _d.decrement(sessionName ? sessionName : this._sessionName, eventName);
            PercyLogger_1.PercyLogger.error(`Error while trying to auto capture Percy screenshot ${err}`);
        }
    }
    async before() {
        this._percyCaptureMap = new PercyCaptureMap_1.default();
    }
    deferCapture(sessionName, eventName) {
        /* Service doesn't wait for handling of browser commands so the below counter is used in teardown method to delay service exit */
        this._percyScreenshotCounter += 1;
        this._percyDeferredScreenshots.push({ sessionName, eventName });
    }
    isDOMChangingCommand(args) {
        var _a;
        if (args.method === 'POST') {
            if (constants_1.PERCY_DOM_CHANGING_COMMANDS_ENDPOINTS.includes(args.endpoint)) {
                return true;
            }
            else if (args.endpoint.includes('/session/:sessionId/element') && args.endpoint.includes('click')) {
                /* click element */
                return true;
            }
            else if (args.endpoint.includes('/session/:sessionId/element') && args.endpoint.includes('clear')) {
                /* clear element */
                return true;
            }
            else if (args.endpoint.includes('/session/:sessionId/execute') && ((_a = args.body) === null || _a === void 0 ? void 0 : _a.script)) {
                /* execute script sync / async */
                return true;
            }
            else if (args.endpoint.includes('/session/:sessionId/touch')) {
                /* Touch action for Appium */
                return true;
            }
        }
        else if (args.method === 'DELETE' && args.endpoint === '/session/:sessionId') {
            return true;
        }
        return false;
    }
    async cleanupDeferredScreenshots() {
        this._isPercyCleanupProcessingUnderway = true;
        for await (const entry of this._percyDeferredScreenshots) {
            await this.percyAutoCapture(entry.eventName, entry.sessionName);
        }
        this._percyDeferredScreenshots = [];
        this._isPercyCleanupProcessingUnderway = false;
    }
    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    async browserBeforeCommand(args) {
        try {
            if (this.isDOMChangingCommand(args)) {
                do {
                    await this.sleep(1000);
                } while (this._percyScreenshotInterval);
                this._percyScreenshotInterval = setInterval(async () => {
                    if (!this._isPercyCleanupProcessingUnderway) {
                        clearInterval(this._percyScreenshotInterval);
                        await this.cleanupDeferredScreenshots();
                        this._percyScreenshotInterval = null;
                    }
                }, 1000);
            }
        }
        catch (err) {
            PercyLogger_1.PercyLogger.error(`Error while trying to cleanup deferred screenshots ${err}`);
        }
    }
    async browserAfterCommand(args) {
        try {
            if (args.endpoint && this._percyAutoCaptureMode) {
                let eventName = null;
                if (args.endpoint.includes('click') && ['click', 'auto'].includes(this._percyAutoCaptureMode)) {
                    eventName = 'click';
                }
                else if (args.endpoint.includes('screenshot') && ['screenshot', 'auto'].includes(this._percyAutoCaptureMode)) {
                    eventName = 'screenshot';
                }
                else if (args.endpoint.includes('actions') && ['auto'].includes(this._percyAutoCaptureMode)) {
                    if (args.body && args.body.actions && Array.isArray(args.body.actions) && args.body.actions.length && args.body.actions[0].type === 'key') {
                        eventName = 'keys';
                    }
                }
                else if (args.endpoint.includes('/session/:sessionId/element') && args.endpoint.includes('value') && ['auto'].includes(this._percyAutoCaptureMode)) {
                    eventName = 'keys';
                }
                if (eventName) {
                    this.deferCapture(this._sessionName, eventName);
                }
            }
        }
        catch (err) {
            PercyLogger_1.PercyLogger.error(`Error while trying to calculate auto capture parameters ${err}`);
        }
    }
    async afterTest() {
        if (this._percyAutoCaptureMode && this._percyAutoCaptureMode === 'testcase') {
            await this.percyAutoCapture('testcase', null);
        }
    }
    async afterScenario() {
        if (this._percyAutoCaptureMode && this._percyAutoCaptureMode === 'testcase') {
            await this.percyAutoCapture('testcase', null);
        }
    }
}
// https://github.com/microsoft/TypeScript/issues/6543
const PercyHandler = (0, util_1.o11yClassErrorHandler)(_PercyHandler);
exports.default = PercyHandler;

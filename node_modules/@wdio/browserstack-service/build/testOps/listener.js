"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const usageStats_1 = __importDefault(require("./usageStats"));
const request_handler_1 = __importDefault(require("../request-handler"));
const util_1 = require("../util");
const constants_1 = require("../constants");
const requestUtils_1 = require("./requestUtils");
const bstackLogger_1 = require("../bstackLogger");
class Listener {
    // Making the constructor private to use singleton pattern
    constructor() {
        this.usageStats = usageStats_1.default.getInstance();
        this.testStartedStats = this.usageStats.testStartedStats;
        this.testFinishedStats = this.usageStats.testFinishedStats;
        this.hookStartedStats = this.usageStats.hookStartedStats;
        this.hookFinishedStats = this.usageStats.hookFinishedStats;
        this.cbtSessionStats = this.usageStats.cbtSessionStats;
        this.logEvents = this.usageStats.logStats;
        this.pendingUploads = 0;
    }
    static getInstance() {
        if (!Listener.instance) {
            Listener.instance = new Listener();
        }
        return Listener.instance;
    }
    async onWorkerEnd() {
        try {
            await this.uploadPending();
            await this.teardown();
        }
        catch (e) {
            bstackLogger_1.BStackLogger.debug('Exception in onWorkerEnd: ' + e);
        }
    }
    async uploadPending(waitTimeout = constants_1.DEFAULT_WAIT_TIMEOUT_FOR_PENDING_UPLOADS, waitInterval = constants_1.DEFAULT_WAIT_INTERVAL_FOR_PENDING_UPLOADS) {
        if ((this.pendingUploads <= 0) || waitTimeout <= 0) {
            return;
        }
        await (0, util_1.sleep)(waitInterval);
        return this.uploadPending(waitTimeout - waitInterval);
    }
    async teardown() {
        var _a;
        bstackLogger_1.BStackLogger.debug('teardown started');
        if (this.requestBatcher) {
            this.requestBatcher.tearDownInvoked = true;
        }
        await ((_a = this.requestBatcher) === null || _a === void 0 ? void 0 : _a.shutdown());
        bstackLogger_1.BStackLogger.debug('teardown ended');
    }
    hookStarted(hookData) {
        try {
            this.hookStartedStats.triggered();
            this.sendBatchEvents(this.getEventForHook('HookRunStarted', hookData));
        }
        catch (e) {
            this.hookStartedStats.failed();
            throw e;
        }
    }
    hookFinished(hookData) {
        try {
            this.hookFinishedStats.triggered(hookData.result);
            this.sendBatchEvents(this.getEventForHook('HookRunFinished', hookData));
        }
        catch (e) {
            this.hookFinishedStats.failed(hookData.result);
            throw e;
        }
    }
    testStarted(testData) {
        try {
            this.testStartedStats.triggered();
            this.sendBatchEvents(this.getEventForHook('TestRunStarted', testData));
        }
        catch (e) {
            this.testStartedStats.failed();
            throw e;
        }
    }
    testFinished(testData) {
        try {
            this.testFinishedStats.triggered(testData.result);
            this.sendBatchEvents(this.getEventForHook('TestRunFinished', testData));
        }
        catch (e) {
            this.testFinishedStats.failed(testData.result);
            throw e;
        }
    }
    logCreated(logs) {
        try {
            this.markLogs('triggered', logs);
            this.sendBatchEvents({
                event_type: 'LogCreated', logs: logs
            });
        }
        catch (e) {
            this.markLogs('failed', logs);
            throw e;
        }
    }
    async onScreenshot(jsonArray) {
        try {
            this.markLogs('triggered', jsonArray);
            this.pendingUploads += 1;
            await (0, requestUtils_1.sendScreenshots)([{
                    event_type: 'LogCreated', logs: jsonArray
                }]);
            this.markLogs('success', jsonArray);
        }
        catch (e) {
            this.markLogs('failed', jsonArray);
            throw e;
        }
        finally {
            this.pendingUploads -= 1;
        }
    }
    cbtSessionCreated(data) {
        try {
            this.cbtSessionStats.triggered();
            this.sendBatchEvents({ event_type: 'CBTSessionCreated', test_run: data });
        }
        catch (e) {
            this.cbtSessionStats.failed();
            throw e;
        }
    }
    markLogs(status, data) {
        if (!data) {
            bstackLogger_1.BStackLogger.debug('No log data');
            return;
        }
        try {
            for (const _log of data) {
                const kind = _log.kind;
                this.logEvents.mark(status, constants_1.LOG_KIND_USAGE_MAP[kind] || kind);
            }
        }
        catch (e) {
            bstackLogger_1.BStackLogger.debug('Exception in marking logs status ' + e);
            throw e;
        }
    }
    getResult(jsonObject, kind) {
        const runStr = kind === 'test' ? 'test_run' : 'hook_run';
        const runData = jsonObject[runStr];
        return runData === null || runData === void 0 ? void 0 : runData.result;
    }
    sendBatchEvents(jsonObject) {
        if (!this.requestBatcher) {
            this.requestBatcher = request_handler_1.default.getInstance(async (data) => {
                bstackLogger_1.BStackLogger.debug('callback: called with events ' + data.length);
                try {
                    this.pendingUploads += 1;
                    await (0, util_1.batchAndPostEvents)(constants_1.DATA_BATCH_ENDPOINT, 'BATCH_DATA', data);
                    bstackLogger_1.BStackLogger.debug('callback: marking events success ' + data.length);
                    this.eventsSuccess(data);
                }
                catch (e) {
                    bstackLogger_1.BStackLogger.debug('callback: marking events failed ' + data.length);
                    this.eventsFailed(data);
                }
                finally {
                    this.pendingUploads -= 1;
                }
            });
        }
        this.requestBatcher.add(jsonObject);
    }
    eventsFailed(events) {
        for (const event of events) {
            const eventType = event.event_type;
            if (eventType === 'TestRunStarted') {
                this.testStartedStats.failed();
            }
            else if (eventType === 'TestRunFinished') {
                this.testFinishedStats.failed(this.getResult(event, 'test'));
            }
            else if (eventType === 'HookRunStarted') {
                this.hookStartedStats.failed();
            }
            else if (eventType === 'HookRunFinished') {
                this.hookFinishedStats.failed(this.getResult(event, 'hook'));
            }
            else if (eventType === 'CBTSessionCreated') {
                this.cbtSessionStats.failed();
            }
            else if (eventType === 'LogCreated') {
                this.markLogs('failed', event.logs);
            }
        }
    }
    eventsSuccess(events) {
        for (const event of events) {
            const eventType = event.event_type;
            if (eventType === 'TestRunStarted') {
                this.testStartedStats.success();
            }
            else if (eventType === 'TestRunFinished') {
                this.testFinishedStats.success(this.getResult(event, 'test'));
            }
            else if (eventType === 'HookRunStarted') {
                this.hookStartedStats.success();
            }
            else if (eventType === 'HookRunFinished') {
                this.hookFinishedStats.success(this.getResult(event, 'hook'));
            }
            else if (eventType === 'CBTSessionCreated') {
                this.cbtSessionStats.success();
            }
            else if (eventType === 'LogCreated') {
                this.markLogs('success', event.logs);
            }
        }
    }
    getEventForHook(eventType, data) {
        return {
            event_type: eventType, [data.type === 'hook' ? 'hook_run' : 'test_run']: data
        };
    }
}
exports.default = Listener;

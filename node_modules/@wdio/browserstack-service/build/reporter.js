"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_path_1 = __importDefault(require("node:path"));
const node_url_1 = __importDefault(require("node:url"));
const reporter_1 = __importDefault(require("@wdio/reporter"));
const uuid_1 = require("uuid");
const logger_1 = __importDefault(require("@wdio/logger"));
const util_1 = require("./util");
const listener_1 = __importDefault(require("./testOps/listener"));
const log = (0, logger_1.default)('@wdio/browserstack-service');
class _TestReporter extends reporter_1.default {
    constructor() {
        super(...arguments);
        this._capabilities = {};
        this._observability = true;
        this._suites = [];
        this._gitConfigured = false;
        this._currentHook = {};
        this._currentTest = {};
        this._userCaps = {};
        this.listener = listener_1.default.getInstance();
    }
    async onRunnerStart(runnerStats) {
        this._capabilities = runnerStats.capabilities;
        this._userCaps = this.getUserCaps(runnerStats);
        this._config = runnerStats.config;
        this._sessionId = runnerStats.sessionId;
        if (typeof this._config.testObservability !== 'undefined')
            this._observability = this._config.testObservability;
        await this.configureGit();
        this.registerListeners();
    }
    registerListeners() {
        var _a;
        if (((_a = this._config) === null || _a === void 0 ? void 0 : _a.framework) !== 'jasmine') {
            return;
        }
        process.removeAllListeners(`bs:addLog:${process.pid}`);
        process.on(`bs:addLog:${process.pid}`, this.appendTestItemLog.bind(this));
    }
    getUserCaps(runnerStats) {
        var _a;
        return (_a = runnerStats.instanceOptions[runnerStats.sessionId]) === null || _a === void 0 ? void 0 : _a.capabilities;
    }
    async appendTestItemLog(stdLog) {
        if (this._currentHook.uuid && !this._currentHook.finished) {
            stdLog.hook_run_uuid = this._currentHook.uuid;
        }
        else if (this._currentTest.uuid) {
            stdLog.test_run_uuid = this._currentTest.uuid;
        }
        if (stdLog.hook_run_uuid || stdLog.test_run_uuid) {
            this.listener.logCreated([stdLog]);
        }
    }
    setCurrentHook(hookDetails) {
        if (hookDetails.finished) {
            if (this._currentHook.uuid === hookDetails.uuid) {
                this._currentHook.finished = true;
            }
            return;
        }
        this._currentHook = {
            uuid: hookDetails.uuid,
            finished: false
        };
    }
    async configureGit() {
        if (this._gitConfigured) {
            return;
        }
        const gitMeta = await (0, util_1.getGitMetaData)();
        if (gitMeta) {
            this._gitConfigPath = gitMeta.root;
        }
        this._gitConfigured = true;
    }
    static getTests() {
        return _TestReporter._tests;
    }
    onSuiteStart(suiteStats) {
        var _a;
        let filename = suiteStats.file;
        if (((_a = this._config) === null || _a === void 0 ? void 0 : _a.framework) == 'jasmine') {
            try {
                if (suiteStats.file.startsWith('file://')) {
                    filename = node_url_1.default.fileURLToPath(suiteStats.file);
                }
                if (filename === 'unknown spec file') {
                    // Sometimes in cases where a file has two suites. Then the file name be unknown for second suite, so getting the filename from first suite
                    filename = this._suiteName || suiteStats.file;
                }
            }
            catch (e) {
                log.debug('Error in decoding file name of suite');
            }
        }
        this._suiteName = filename;
        this._suites.push(suiteStats);
    }
    onSuiteEnd() {
        this._suites.pop();
    }
    needToSendData(testType, event) {
        var _a;
        if (!this._observability)
            return false;
        switch ((_a = this._config) === null || _a === void 0 ? void 0 : _a.framework) {
            case 'mocha':
                return event === 'skip';
            case 'cucumber':
                return false;
            case 'jasmine':
                return event !== 'skip';
            default:
                return false;
        }
    }
    async onTestEnd(testStats) {
        if (!this.needToSendData('test', 'end'))
            return;
        if (testStats.fullTitle === '<unknown test>')
            return;
        testStats.end || (testStats.end = new Date());
        this.listener.testFinished(await this.getRunData(testStats, 'TestRunFinished'));
    }
    async onTestStart(testStats) {
        if (!this.needToSendData('test', 'start'))
            return;
        if (testStats.fullTitle === '<unknown test>')
            return;
        const uuid = (0, uuid_1.v4)();
        this._currentTest.uuid = uuid;
        _TestReporter._tests[testStats.fullTitle] = {
            uuid: uuid,
        };
        this.listener.testStarted(await this.getRunData(testStats, 'TestRunStarted'));
    }
    async onHookStart(hookStats) {
        if (!this.needToSendData('hook', 'start')) {
            return;
        }
        const identifier = this.getHookIdentifier(hookStats);
        const hookId = (0, uuid_1.v4)();
        this.setCurrentHook({ uuid: hookId });
        _TestReporter._tests[identifier] = {
            uuid: hookId,
            startedAt: (new Date()).toISOString()
        };
        this.listener.hookStarted(await this.getRunData(hookStats, 'HookRunStarted'));
    }
    async onHookEnd(hookStats) {
        if (!this.needToSendData('hook', 'end')) {
            return;
        }
        const identifier = this.getHookIdentifier(hookStats);
        if (_TestReporter._tests[identifier]) {
            _TestReporter._tests[identifier].finishedAt = (new Date()).toISOString();
        }
        else {
            _TestReporter._tests[identifier] = {
                finishedAt: (new Date()).toISOString()
            };
        }
        this.setCurrentHook({ uuid: _TestReporter._tests[identifier].uuid, finished: true });
        if (!hookStats.state && !hookStats.error) {
            hookStats.state = 'passed';
        }
        this.listener.hookFinished(await this.getRunData(hookStats, 'HookRunFinished'));
    }
    getHookIdentifier(hookStats) {
        var _a;
        return `${hookStats.title} for ${(_a = this._suites.at(-1)) === null || _a === void 0 ? void 0 : _a.title}`;
    }
    async getRunData(testStats, eventType) {
        var _a, _b, _c, _d, _e, _f;
        const framework = (_a = this._config) === null || _a === void 0 ? void 0 : _a.framework;
        const scopes = this._suites.map(s => s.title);
        const identifier = testStats.type === 'test' ? testStats.fullTitle : this.getHookIdentifier(testStats);
        const testMetaData = _TestReporter._tests[identifier];
        const scope = testStats.type === 'test' ? testStats.fullTitle : `${this._suites[0].title} - ${testStats.title}`;
        await this.configureGit();
        let testData = {
            uuid: testMetaData ? testMetaData.uuid : (0, uuid_1.v4)(),
            type: testStats.type,
            name: testStats.title,
            body: {
                lang: 'webdriverio',
                code: null
            },
            scope: scope,
            scopes: scopes,
            identifier: identifier,
            file_name: this._suiteName ? node_path_1.default.relative(process.cwd(), this._suiteName) : undefined,
            location: this._suiteName ? node_path_1.default.relative(process.cwd(), this._suiteName) : undefined,
            vc_filepath: (this._gitConfigPath && this._suiteName) ? node_path_1.default.relative(this._gitConfigPath, this._suiteName) : undefined,
            started_at: testStats.start && testStats.start.toISOString(),
            finished_at: testStats.end && testStats.end.toISOString(),
            framework: framework,
            duration_in_ms: testStats._duration,
            result: testStats.state,
        };
        if (testStats.type === 'test') {
            testData.retries = { limit: testStats.retries || 0, attempts: testStats.retries || 0 };
        }
        if (eventType.startsWith('TestRun') || eventType === 'HookRunStarted') {
            /* istanbul ignore next */
            const cloudProvider = (0, util_1.getCloudProvider)({ options: { hostname: (_b = this._config) === null || _b === void 0 ? void 0 : _b.hostname } });
            testData.integrations = {};
            /* istanbul ignore next */
            testData.integrations[cloudProvider] = {
                capabilities: this._capabilities,
                session_id: this._sessionId,
                browser: (_c = this._capabilities) === null || _c === void 0 ? void 0 : _c.browserName,
                browser_version: (_d = this._capabilities) === null || _d === void 0 ? void 0 : _d.browserVersion,
                platform: (_e = this._capabilities) === null || _e === void 0 ? void 0 : _e.platformName,
                platform_version: (0, util_1.getPlatformVersion)(this._userCaps)
            };
        }
        if (eventType == 'TestRunFinished' || eventType == 'HookRunFinished') {
            const { error } = testStats;
            const failed = testStats.state == 'failed';
            if (failed) {
                testData.result = (error && error.message && error.message.includes('sync skip; aborting execution')) ? 'ignore' : 'failed';
                if (error && testData.result != 'skipped') {
                    testData.failure = [{ backtrace: [(0, util_1.removeAnsiColors)(error.message)] }]; // add all errors here
                    testData.failure_reason = (0, util_1.removeAnsiColors)(error.message);
                    testData.failure_type = error.message == null ? null : error.message.toString().match(/AssertionError/) ? 'AssertionError' : 'UnhandledError'; //verify if this is working
                }
            }
        }
        if (eventType == 'TestRunSkipped') {
            eventType = 'TestRunFinished';
        }
        if (eventType.match(/HookRun/)) {
            testData.hook_type = ((_f = testData.name) === null || _f === void 0 ? void 0 : _f.toLowerCase()) ? (0, util_1.getHookType)(testData.name.toLowerCase()) : 'undefined';
        }
        return testData;
    }
    async onTestSkip(testStats) {
        // cucumber steps call this method. We don't want step skipped state so skip for cucumber
        if (!this.needToSendData('test', 'skip'))
            return;
        testStats.start || (testStats.start = new Date());
        testStats.end || (testStats.end = new Date());
        this.listener.testFinished(await this.getRunData(testStats, 'TestRunSkipped'));
    }
}
_TestReporter._tests = {};
// https://github.com/microsoft/TypeScript/issues/6543
const TestReporter = (0, util_1.o11yClassErrorHandler)(_TestReporter);
exports.default = TestReporter;

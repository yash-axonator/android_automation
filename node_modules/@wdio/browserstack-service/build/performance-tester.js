"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const csv_writer_1 = require("csv-writer");
const fs_1 = __importDefault(require("fs"));
const perf_hooks_1 = require("perf_hooks");
const logger_1 = __importDefault(require("@wdio/logger"));
const util_1 = require("./util");
const log = (0, logger_1.default)('@wdio/browserstack-service');
class PerformanceTester {
    static startMonitoring(csvName = 'performance-report.csv') {
        this._observer = new perf_hooks_1.PerformanceObserver(list => {
            list.getEntries().forEach(entry => {
                this._events.push(entry);
            });
        });
        this._observer.observe({ buffered: true, entryTypes: ['function'] });
        this.started = true;
        this._csvWriter = (0, csv_writer_1.createObjectCsvWriter)({
            path: csvName,
            header: [
                { id: 'name', title: 'Function Name' },
                { id: 'time', title: 'Execution Time (ms)' }
            ]
        });
    }
    static getPerformance() {
        return perf_hooks_1.performance;
    }
    static calculateTimes(methods) {
        const times = {};
        this._events.map((entry) => {
            if (!times[entry.name]) {
                times[entry.name] = 0;
            }
            times[entry.name] += entry.duration;
        });
        const timeTaken = methods.reduce((a, c) => {
            return times[c] + (a || 0);
        }, 0);
        log.info(`Time for ${methods} is `, timeTaken);
        return timeTaken;
    }
    static async stopAndGenerate(filename = 'performance-own.html') {
        if (!this.started)
            return;
        await (0, util_1.sleep)(2000); // Wait to 2s just to finish any running callbacks for timerify
        this._observer.disconnect();
        this.started = false;
        this.generateCSV(this._events);
        const content = this.generateReport(this._events);
        const path = process.cwd() + '/' + filename;
        fs_1.default.writeFile(path, content, err => {
            if (err) {
                log.error('Error in writing html', err);
                return;
            }
            log.info('Performance report is at ', path);
        });
    }
    static generateReport(entries) {
        let html = '<!DOCTYPE html><html><head><title>Performance Report</title></head><body>';
        html += '<h1>Performance Report</h1>';
        html += '<table><thead><tr><th>Function Name</th><th>Duration (ms)</th></tr></thead><tbody>';
        entries.forEach((entry) => {
            html += `<tr><td>${entry.name}</td><td>${entry.duration}</td></tr>`;
        });
        html += '</tbody></table></body></html>';
        return html;
    }
    static generateCSV(entries) {
        const times = {};
        entries.map((entry) => {
            if (!times[entry.name]) {
                times[entry.name] = 0;
            }
            times[entry.name] += entry.duration;
            return {
                name: entry.name,
                time: entry.duration
            };
        });
        const dat = Object.entries(times).map(([key, value]) => {
            return {
                name: key,
                time: value
            };
        });
        this._csvWriter.writeRecords(dat)
            .then(() => log.info('Performance CSV report generated successfully'))
            .catch((error) => console.error(error));
    }
}
PerformanceTester._events = [];
PerformanceTester.started = false;
exports.default = PerformanceTester;

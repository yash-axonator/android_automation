"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPlatformVersion = exports.ObjectsAreEqual = exports.isObject = exports.isTrue = exports.isUndefined = exports.getBrowserStackKey = exports.getBrowserStackUser = exports.stopAccessibilityTestRun = exports.getA11yResultsSummary = exports.getA11yResults = exports.performA11yScan = exports.createAccessibilityTestRun = exports.isAccessibilityAutomationSession = exports.shouldScanTestForAccessibility = exports.validateCapsWithA11y = exports.sleep = exports.patchConsoleLogs = exports.getFailureObject = exports.frameworkSupportsHook = exports.getObservabilityBuildTags = exports.getObservabilityBuild = exports.getObservabilityProject = exports.getObservabilityKey = exports.getObservabilityUser = exports.batchAndPostEvents = exports.shouldAddServiceVersion = exports.isBStackSession = exports.isScreenshotCommand = exports.getHookType = exports.getHierarchy = exports.getLogTag = exports.removeAnsiColors = exports.getScenarioExamples = exports.isBrowserstackSession = exports.getCloudProvider = exports.getUniqueIdentifierForCucumber = exports.getUniqueIdentifier = exports.getGitMetaData = exports.nodeRequest = exports.getCiInfo = exports.stopBuildUpstream = exports.launchTestSession = exports.o11yClassErrorHandler = exports.o11yErrorHandler = exports.errorHandler = exports.getParentSuiteName = exports.isBrowserstackCapability = exports.getBrowserCapabilities = exports.getBrowserDescription = exports.DEFAULT_REQUEST_CONFIG = void 0;
exports.getErrorString = exports.isObjectEmpty = void 0;
const os_1 = require("os");
const util_1 = require("util");
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const path_1 = __importDefault(require("path"));
const util_2 = __importDefault(require("util"));
const logger_1 = __importDefault(require("@wdio/logger"));
const got_1 = __importStar(require("got"));
const git_repo_info_1 = __importDefault(require("git-repo-info"));
const gitconfiglocal_1 = __importDefault(require("gitconfiglocal"));
const crash_reporter_1 = __importDefault(require("./crash-reporter"));
const logPatcher_1 = __importDefault(require("./logPatcher"));
const constants_1 = require("./constants");
const performance_tester_1 = __importDefault(require("./performance-tester"));
const accessibility_scripts_1 = __importDefault(require("./scripts/accessibility-scripts"));
const usageStats_1 = __importDefault(require("./testOps/usageStats"));
const testOpsConfig_1 = __importDefault(require("./testOps/testOpsConfig"));
const pGitconfig = (0, util_1.promisify)(gitconfiglocal_1.default);
const log = (0, logger_1.default)('@wdio/browserstack-service');
exports.DEFAULT_REQUEST_CONFIG = {
    agent: {
        http: new http_1.default.Agent({ keepAlive: true }),
        https: new https_1.default.Agent({ keepAlive: true }),
    },
    headers: {
        'Content-Type': 'application/json',
        'X-BSTACK-OBS': 'true'
    },
};
/**
 * get browser description for Browserstack service
 * @param cap browser capablities
 */
function getBrowserDescription(cap) {
    cap = cap || {};
    if (cap['bstack:options']) {
        cap = { ...cap, ...cap['bstack:options'] };
    }
    /**
     * These keys describe the browser the test was run on
     */
    return constants_1.BROWSER_DESCRIPTION
        .map((k) => cap[k])
        .filter(Boolean)
        .join(' ');
}
exports.getBrowserDescription = getBrowserDescription;
/**
 * get correct browser capabilities object in both multiremote and normal setups
 * @param browser browser object
 * @param caps browser capbilities object. In case of multiremote, the object itself should have a property named 'capabilities'
 * @param browserName browser name in case of multiremote
 */
function getBrowserCapabilities(browser, caps, browserName) {
    if (!browser.isMultiremote) {
        return { ...browser.capabilities, ...caps };
    }
    const multiCaps = caps;
    const globalCap = browserName && browser[browserName] ? browser[browserName].capabilities : {};
    const cap = browserName && multiCaps[browserName] ? multiCaps[browserName].capabilities : {};
    return { ...globalCap, ...cap };
}
exports.getBrowserCapabilities = getBrowserCapabilities;
/**
 * check for browserstack W3C capabilities. Does not support legacy capabilities
 * @param cap browser capabilities
 */
function isBrowserstackCapability(cap) {
    return Boolean(cap &&
        cap['bstack:options'] &&
        // return false if the only cap in bstack:options is wdioService,
        // as that is added by the service and not present in user passed caps
        !(Object.keys(cap['bstack:options']).length === 1 &&
            cap['bstack:options'].wdioService));
}
exports.isBrowserstackCapability = isBrowserstackCapability;
function getParentSuiteName(fullTitle, testSuiteTitle) {
    const fullTitleWords = fullTitle.split(' ');
    const testSuiteTitleWords = testSuiteTitle.split(' ');
    const shortestLength = Math.min(fullTitleWords.length, testSuiteTitleWords.length);
    let c = 0;
    let parentSuiteName = '';
    while (c < shortestLength && fullTitleWords[c] === testSuiteTitleWords[c]) {
        parentSuiteName += fullTitleWords[c++] + ' ';
    }
    return parentSuiteName.trim();
}
exports.getParentSuiteName = getParentSuiteName;
function processError(error, fn, args) {
    log.error(`Error in executing ${fn.name} with args ${args}: ${error}`);
    let argsString;
    try {
        argsString = JSON.stringify(args);
    }
    catch (e) {
        argsString = util_2.default.inspect(args, { depth: 2 });
    }
    crash_reporter_1.default.uploadCrashReport(`Error in executing ${fn.name} with args ${argsString} : ${error}`, error && error.stack);
}
function errorHandler(fn) {
    return function (...args) {
        try {
            const functionToHandle = fn;
            const result = functionToHandle(...args);
            if (result instanceof Promise) {
                return result.catch(error => log.error(`Error in executing ${fn.name} with args ${args}: ${error}`));
            }
            return result;
        }
        catch (error) {
            log.error(`Error in executing ${fn.name} with args ${args}: ${error}`);
        }
    };
}
exports.errorHandler = errorHandler;
function o11yErrorHandler(fn) {
    return function (...args) {
        try {
            let functionToHandle = fn;
            if (process.env[constants_1.PERF_MEASUREMENT_ENV]) {
                functionToHandle = performance_tester_1.default.getPerformance().timerify(functionToHandle);
            }
            const result = functionToHandle(...args);
            if (result instanceof Promise) {
                return result.catch(error => processError(error, fn, args));
            }
            return result;
        }
        catch (error) {
            processError(error, fn, args);
        }
    };
}
exports.o11yErrorHandler = o11yErrorHandler;
function o11yClassErrorHandler(errorClass) {
    const prototype = errorClass.prototype;
    if (Object.getOwnPropertyNames(prototype).length < 2) {
        return errorClass;
    }
    Object.getOwnPropertyNames(prototype).forEach((methodName) => {
        const method = prototype[methodName];
        if (typeof method === 'function' && methodName !== 'constructor') {
            // In order to preserve this context, need to define like this
            Object.defineProperty(prototype, methodName, {
                writable: true,
                value: function (...args) {
                    try {
                        const result = (process.env[constants_1.PERF_MEASUREMENT_ENV] ? performance_tester_1.default.getPerformance().timerify(method) : method).call(this, ...args);
                        if (result instanceof Promise) {
                            return result.catch(error => processError(error, method, args));
                        }
                        return result;
                    }
                    catch (err) {
                        processError(err, method, args);
                    }
                }
            });
        }
    });
    return errorClass;
}
exports.o11yClassErrorHandler = o11yClassErrorHandler;
exports.launchTestSession = o11yErrorHandler(async function launchTestSession(options, config, bsConfig) {
    const launchBuildUsage = usageStats_1.default.getInstance().launchBuildUsage;
    launchBuildUsage.triggered();
    const data = {
        format: 'json',
        project_name: getObservabilityProject(options, bsConfig.projectName),
        name: getObservabilityBuild(options, bsConfig.buildName),
        build_identifier: bsConfig.buildIdentifier,
        start_time: (new Date()).toISOString(),
        tags: getObservabilityBuildTags(options, bsConfig.buildTag),
        host_info: {
            hostname: (0, os_1.hostname)(),
            platform: (0, os_1.platform)(),
            type: (0, os_1.type)(),
            version: (0, os_1.version)(),
            arch: (0, os_1.arch)()
        },
        ci_info: getCiInfo(),
        build_run_identifier: process.env.BROWSERSTACK_BUILD_RUN_IDENTIFIER,
        failed_tests_rerun: process.env[constants_1.RERUN_ENV] || false,
        version_control: await getGitMetaData(),
        observability_version: {
            frameworkName: 'WebdriverIO-' + config.framework,
            sdkVersion: bsConfig.bstackServiceVersion
        },
        config: {}
    };
    try {
        if (Object.keys(crash_reporter_1.default.userConfigForReporting).length === 0) {
            crash_reporter_1.default.userConfigForReporting = process.env.USER_CONFIG_FOR_REPORTING !== undefined ? JSON.parse(process.env.USER_CONFIG_FOR_REPORTING) : {};
        }
    }
    catch (error) {
        log.error(`[Crash_Report_Upload] Failed to parse user config while sending build start event due to ${error}`);
    }
    data.config = crash_reporter_1.default.userConfigForReporting;
    try {
        const url = `${constants_1.DATA_ENDPOINT}/api/v1/builds`;
        const response = await got_1.default.post(url, {
            ...exports.DEFAULT_REQUEST_CONFIG,
            username: getObservabilityUser(options, config),
            password: getObservabilityKey(options, config),
            json: data
        }).json();
        log.debug(`[Start_Build] Success response: ${JSON.stringify(response)}`);
        process.env[constants_1.TESTOPS_BUILD_COMPLETED_ENV] = 'true';
        if (response.jwt) {
            process.env[constants_1.TESTOPS_JWT_ENV] = response.jwt;
            launchBuildUsage.success();
        }
        if (response.build_hashed_id) {
            process.env[constants_1.TESTOPS_BUILD_ID_ENV] = response.build_hashed_id;
            testOpsConfig_1.default.getInstance().buildHashedId = response.build_hashed_id;
        }
        if (response.allow_screenshots)
            process.env[constants_1.TESTOPS_SCREENSHOT_ENV] = response.allow_screenshots.toString();
    }
    catch (error) {
        if (error instanceof got_1.HTTPError && error.response) {
            const errorMessageJson = error.response.body ? JSON.parse(error.response.body.toString()) : null;
            const errorMessage = errorMessageJson ? errorMessageJson.message : null, errorType = errorMessageJson ? errorMessageJson.errorType : null;
            switch (errorType) {
                case 'ERROR_INVALID_CREDENTIALS':
                    log.error(errorMessage);
                    break;
                case 'ERROR_ACCESS_DENIED':
                    log.info(errorMessage);
                    break;
                case 'ERROR_SDK_DEPRECATED':
                    log.error(errorMessage);
                    break;
                default:
                    log.error(errorMessage);
            }
            launchBuildUsage.failed(errorMessage || error);
        }
        else {
            log.error(`Data upload to BrowserStack Test Observability failed due to ${error}`);
            launchBuildUsage.failed(error);
        }
    }
});
exports.stopBuildUpstream = o11yErrorHandler(async function stopBuildUpstream() {
    const stopBuildUsage = usageStats_1.default.getInstance().stopBuildUsage;
    stopBuildUsage.triggered();
    if (!process.env[constants_1.TESTOPS_BUILD_COMPLETED_ENV]) {
        stopBuildUsage.failed('Build is not completed yet');
        return {
            status: 'error',
            message: 'Build is not completed yet'
        };
    }
    if (!process.env[constants_1.TESTOPS_JWT_ENV]) {
        log.debug('[STOP_BUILD] Missing Authentication Token/ Build ID');
        stopBuildUsage.failed('Token/buildID is undefined, build creation might have failed');
        return {
            status: 'error',
            message: 'Token/buildID is undefined, build creation might have failed'
        };
    }
    const data = {
        'stop_time': (new Date()).toISOString()
    };
    try {
        const url = `${constants_1.DATA_ENDPOINT}/api/v1/builds/${process.env[constants_1.TESTOPS_BUILD_ID_ENV]}/stop`;
        const response = await got_1.default.put(url, {
            agent: exports.DEFAULT_REQUEST_CONFIG.agent,
            headers: {
                ...exports.DEFAULT_REQUEST_CONFIG.headers,
                'Authorization': `Bearer ${process.env[constants_1.TESTOPS_JWT_ENV]}`
            },
            json: data
        }).json();
        log.debug(`[STOP_BUILD] Success response: ${JSON.stringify(response)}`);
        stopBuildUsage.success();
        return {
            status: 'success',
            message: ''
        };
    }
    catch (error) {
        stopBuildUsage.failed(error);
        log.debug(`[STOP_BUILD] Failed. Error: ${error}`);
        return {
            status: 'error',
            message: error.message
        };
    }
});
function getCiInfo() {
    const env = process.env;
    // Jenkins
    if ((typeof env.JENKINS_URL === 'string' && env.JENKINS_URL.length > 0) || (typeof env.JENKINS_HOME === 'string' && env.JENKINS_HOME.length > 0)) {
        return {
            name: 'Jenkins',
            build_url: env.BUILD_URL,
            job_name: env.JOB_NAME,
            build_number: env.BUILD_NUMBER
        };
    }
    // CircleCI
    if (isTrue(env.CI) && isTrue(env.CIRCLECI)) {
        return {
            name: 'CircleCI',
            build_url: env.CIRCLE_BUILD_URL,
            job_name: env.CIRCLE_JOB,
            build_number: env.CIRCLE_BUILD_NUM
        };
    }
    // Travis CI
    if (isTrue(env.CI) && isTrue(env.TRAVIS)) {
        return {
            name: 'Travis CI',
            build_url: env.TRAVIS_BUILD_WEB_URL,
            job_name: env.TRAVIS_JOB_NAME,
            build_number: env.TRAVIS_BUILD_NUMBER
        };
    }
    // Codeship
    if (isTrue(env.CI) && env.CI_NAME === 'codeship') {
        return {
            name: 'Codeship',
            build_url: null,
            job_name: null,
            build_number: null
        };
    }
    // Bitbucket
    if (env.BITBUCKET_BRANCH && env.BITBUCKET_COMMIT) {
        return {
            name: 'Bitbucket',
            build_url: env.BITBUCKET_GIT_HTTP_ORIGIN,
            job_name: null,
            build_number: env.BITBUCKET_BUILD_NUMBER
        };
    }
    // Drone
    if (isTrue(env.CI) && isTrue(env.DRONE)) {
        return {
            name: 'Drone',
            build_url: env.DRONE_BUILD_LINK,
            job_name: null,
            build_number: env.DRONE_BUILD_NUMBER
        };
    }
    // Semaphore
    if (isTrue(env.CI) && isTrue(env.SEMAPHORE)) {
        return {
            name: 'Semaphore',
            build_url: env.SEMAPHORE_ORGANIZATION_URL,
            job_name: env.SEMAPHORE_JOB_NAME,
            build_number: env.SEMAPHORE_JOB_ID
        };
    }
    // GitLab
    if (isTrue(env.CI) && isTrue(env.GITLAB_CI)) {
        return {
            name: 'GitLab',
            build_url: env.CI_JOB_URL,
            job_name: env.CI_JOB_NAME,
            build_number: env.CI_JOB_ID
        };
    }
    // Buildkite
    if (isTrue(env.CI) && isTrue(env.BUILDKITE)) {
        return {
            name: 'Buildkite',
            build_url: env.BUILDKITE_BUILD_URL,
            job_name: env.BUILDKITE_LABEL || env.BUILDKITE_PIPELINE_NAME,
            build_number: env.BUILDKITE_BUILD_NUMBER
        };
    }
    // Visual Studio Team Services
    if (isTrue(env.TF_BUILD) && env.TF_BUILD_BUILDNUMBER) {
        return {
            name: 'Visual Studio Team Services',
            build_url: `${env.SYSTEM_TEAMFOUNDATIONSERVERURI}${env.SYSTEM_TEAMPROJECTID}`,
            job_name: env.SYSTEM_DEFINITIONID,
            build_number: env.BUILD_BUILDID
        };
    }
    // Appveyor
    if (isTrue(env.APPVEYOR)) {
        return {
            name: 'Appveyor',
            build_url: `${env.APPVEYOR_URL}/project/${env.APPVEYOR_ACCOUNT_NAME}/${env.APPVEYOR_PROJECT_SLUG}/builds/${env.APPVEYOR_BUILD_ID}`,
            job_name: env.APPVEYOR_JOB_NAME,
            build_number: env.APPVEYOR_BUILD_NUMBER
        };
    }
    // Azure CI
    if (env.AZURE_HTTP_USER_AGENT && env.TF_BUILD) {
        return {
            name: 'Azure CI',
            build_url: `${env.SYSTEM_TEAMFOUNDATIONSERVERURI}${env.SYSTEM_TEAMPROJECT}/_build/results?buildId=${env.BUILD_BUILDID}`,
            job_name: env.BUILD_BUILDID,
            build_number: env.BUILD_BUILDID
        };
    }
    // AWS CodeBuild
    if (env.CODEBUILD_BUILD_ID || env.CODEBUILD_RESOLVED_SOURCE_VERSION || env.CODEBUILD_SOURCE_VERSION) {
        return {
            name: 'AWS CodeBuild',
            build_url: env.CODEBUILD_PUBLIC_BUILD_URL,
            job_name: env.CODEBUILD_BUILD_ID,
            build_number: env.CODEBUILD_BUILD_ID
        };
    }
    // Bamboo
    if (env.bamboo_buildNumber) {
        return {
            name: 'Bamboo',
            build_url: env.bamboo_buildResultsUrl,
            job_name: env.bamboo_shortJobName,
            build_number: env.bamboo_buildNumber
        };
    }
    // Wercker
    if (env.WERCKER || env.WERCKER_MAIN_PIPELINE_STARTED) {
        return {
            name: 'Wercker',
            build_url: env.WERCKER_BUILD_URL,
            job_name: env.WERCKER_MAIN_PIPELINE_STARTED ? 'Main Pipeline' : null,
            build_number: env.WERCKER_GIT_COMMIT
        };
    }
    // Google Cloud
    if (env.GCP_PROJECT || env.GCLOUD_PROJECT || env.GOOGLE_CLOUD_PROJECT) {
        return {
            name: 'Google Cloud',
            build_url: null,
            job_name: env.PROJECT_ID,
            build_number: env.BUILD_ID,
        };
    }
    // Shippable
    if (env.SHIPPABLE) {
        return {
            name: 'Shippable',
            build_url: env.SHIPPABLE_BUILD_URL,
            job_name: env.SHIPPABLE_JOB_ID ? `Job #${env.SHIPPABLE_JOB_ID}` : null,
            build_number: env.SHIPPABLE_BUILD_NUMBER
        };
    }
    // Netlify
    if (isTrue(env.NETLIFY)) {
        return {
            name: 'Netlify',
            build_url: env.DEPLOY_URL,
            job_name: env.SITE_NAME,
            build_number: env.BUILD_ID
        };
    }
    // Github Actions
    if (isTrue(env.GITHUB_ACTIONS)) {
        return {
            name: 'GitHub Actions',
            build_url: `${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}/actions/runs/${env.GITHUB_RUN_ID}`,
            job_name: env.GITHUB_WORKFLOW,
            build_number: env.GITHUB_RUN_ID,
        };
    }
    // Vercel
    if (isTrue(env.CI) && env.VERCEL === '1') {
        return {
            name: 'Vercel',
            build_url: `http://${env.VERCEL_URL}`,
            job_name: null,
            build_number: null,
        };
    }
    // Teamcity
    if (env.TEAMCITY_VERSION) {
        return {
            name: 'Teamcity',
            build_url: null,
            job_name: null,
            build_number: env.BUILD_NUMBER,
        };
    }
    // Concourse
    if (env.CONCOURSE || env.CONCOURSE_URL || env.CONCOURSE_USERNAME || env.CONCOURSE_TEAM) {
        return {
            name: 'Concourse',
            build_url: null,
            job_name: env.BUILD_JOB_NAME || null,
            build_number: env.BUILD_ID || null,
        };
    }
    // GoCD
    if (env.GO_JOB_NAME) {
        return {
            name: 'GoCD',
            build_url: null,
            job_name: env.GO_JOB_NAME,
            build_number: env.GO_PIPELINE_COUNTER,
        };
    }
    // CodeFresh
    if (env.CF_BUILD_ID) {
        return {
            name: 'CodeFresh',
            build_url: env.CF_BUILD_URL,
            job_name: env.CF_PIPELINE_NAME,
            build_number: env.CF_BUILD_ID,
        };
    }
    // if no matches, return null
    return null;
}
exports.getCiInfo = getCiInfo;
async function nodeRequest(requestType, apiEndpoint, options, apiUrl, timeout = 120000) {
    try {
        const response = await (0, got_1.default)(`${apiUrl}/${apiEndpoint}`, {
            method: requestType,
            timeout: {
                request: timeout
            },
            ...options
        }).json();
        return response;
    }
    catch (error) {
        if (error instanceof got_1.HTTPError && error.response) {
            const errorMessageJson = error.response.body ? JSON.parse(error.response.body.toString()) : null;
            const errorMessage = errorMessageJson ? errorMessageJson.message : null;
            if (errorMessage) {
                log.error(`${errorMessage} - ${error.stack}`);
            }
            else {
                log.error(`${error.stack}`);
            }
            throw error;
        }
        else {
            log.debug(`Failed to fire api request due to ${error} - ${error.stack}`);
            throw error;
        }
    }
}
exports.nodeRequest = nodeRequest;
async function getGitMetaData() {
    var info = (0, git_repo_info_1.default)();
    if (!info.commonGitDir)
        return {};
    const { remote } = await pGitconfig(info.commonGitDir);
    const remotes = remote ? Object.keys(remote).map(remoteName => ({ name: remoteName, url: remote[remoteName]['url'] })) : [];
    return {
        name: 'git',
        sha: info.sha,
        short_sha: info.abbreviatedSha,
        branch: info.branch,
        tag: info.tag,
        committer: info.committer,
        committer_date: info.committerDate,
        author: info.author,
        author_date: info.authorDate,
        commit_message: info.commitMessage,
        root: info.root,
        common_git_dir: info.commonGitDir,
        worktree_git_dir: info.worktreeGitDir,
        last_tag: info.lastTag,
        commits_since_last_tag: info.commitsSinceLastTag,
        remotes: remotes
    };
}
exports.getGitMetaData = getGitMetaData;
function getUniqueIdentifier(test, framework) {
    if (framework === 'jasmine') {
        return test.fullName;
    }
    let parentTitle = test.parent;
    // Sometimes parent will be an object instead of a string
    if (typeof test.parent === 'object') {
        // @ts-ignore
        parentTitle = parentTitle.title;
    }
    return `${parentTitle} - ${test.title}`;
}
exports.getUniqueIdentifier = getUniqueIdentifier;
function getUniqueIdentifierForCucumber(world) {
    return world.pickle.uri + '_' + world.pickle.astNodeIds.join(',');
}
exports.getUniqueIdentifierForCucumber = getUniqueIdentifierForCucumber;
function getCloudProvider(browser) {
    if (browser.options && browser.options.hostname && browser.options.hostname.includes('browserstack')) {
        return 'browserstack';
    }
    return 'unknown_grid';
}
exports.getCloudProvider = getCloudProvider;
function isBrowserstackSession(browser) {
    if (!browser) {
        return false;
    }
    return getCloudProvider(browser).toLowerCase() == 'browserstack';
}
exports.isBrowserstackSession = isBrowserstackSession;
function getScenarioExamples(world) {
    var _a;
    const scenario = world.pickle;
    // no examples present
    if ((scenario.astNodeIds && scenario.astNodeIds.length <= 1) || scenario.astNodeIds == undefined)
        return;
    const pickleId = scenario.astNodeIds[0];
    const examplesId = scenario.astNodeIds[1];
    const gherkinDocumentChildren = (_a = world.gherkinDocument.feature) === null || _a === void 0 ? void 0 : _a.children;
    let examples = [];
    gherkinDocumentChildren === null || gherkinDocumentChildren === void 0 ? void 0 : gherkinDocumentChildren.forEach(child => {
        var _a;
        if (child.rule) {
            // handle if rule is present
            child.rule.children.forEach(childLevel2 => {
                var _a;
                if (childLevel2.scenario && childLevel2.scenario.id == pickleId && childLevel2.scenario.examples) {
                    const passedExamples = (_a = childLevel2.scenario.examples.flatMap((val) => (val.tableBody)).find((item) => item.id == examplesId)) === null || _a === void 0 ? void 0 : _a.cells.map((val) => (val.value));
                    if (passedExamples)
                        examples = passedExamples;
                }
            });
        }
        else if (child.scenario && child.scenario.id == pickleId && child.scenario.examples) {
            // handle if scenario outside rule
            const passedExamples = (_a = child.scenario.examples.flatMap((val) => (val.tableBody)).find((item) => item.id == examplesId)) === null || _a === void 0 ? void 0 : _a.cells.map((val) => (val.value));
            if (passedExamples)
                examples = passedExamples;
        }
    });
    if (examples.length)
        return examples;
    return;
}
exports.getScenarioExamples = getScenarioExamples;
function removeAnsiColors(message) {
    // https://stackoverflow.com/a/29497680
    // eslint-disable-next-line no-control-regex
    return message.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
}
exports.removeAnsiColors = removeAnsiColors;
function getLogTag(eventType) {
    if (eventType == 'TestRunStarted' || eventType == 'TestRunFinished') {
        return 'Test_Upload';
    }
    else if (eventType == 'HookRunStarted' || eventType == 'HookRunFinished') {
        return 'Hook_Upload';
    }
    else if (eventType == 'ScreenshotCreated') {
        return 'Screenshot_Upload';
    }
    else if (eventType == 'LogCreated') {
        return 'Log_Upload';
    }
    return 'undefined';
}
exports.getLogTag = getLogTag;
// get hierarchy for a particular test (called by reporter for skipped tests)
function getHierarchy(fullTitle) {
    if (!fullTitle)
        return [];
    return fullTitle.split('.').slice(0, -1);
}
exports.getHierarchy = getHierarchy;
function getHookType(hookName) {
    if (hookName.startsWith('"before each"')) {
        return 'BEFORE_EACH';
    }
    else if (hookName.startsWith('"before all"')) {
        return 'BEFORE_ALL';
    }
    else if (hookName.startsWith('"after each"')) {
        return 'AFTER_EACH';
    }
    else if (hookName.startsWith('"after all"')) {
        return 'AFTER_ALL';
    }
    return 'unknown';
}
exports.getHookType = getHookType;
function isScreenshotCommand(args) {
    return args.endpoint && args.endpoint.includes('/screenshot');
}
exports.isScreenshotCommand = isScreenshotCommand;
function isBStackSession(config) {
    if (typeof config.user === 'string' && typeof config.key === 'string' && config.key.length === 20) {
        return true;
    }
    return false;
}
exports.isBStackSession = isBStackSession;
function shouldAddServiceVersion(config, testObservability) {
    if (config.services && config.services.toString().includes('chromedriver') && testObservability != false) {
        return false;
    }
    return true;
}
exports.shouldAddServiceVersion = shouldAddServiceVersion;
async function batchAndPostEvents(eventUrl, kind, data) {
    if (!process.env[constants_1.TESTOPS_BUILD_COMPLETED_ENV]) {
        throw new Error('Build not completed yet');
    }
    const jwtToken = process.env[constants_1.TESTOPS_JWT_ENV];
    if (!jwtToken) {
        throw new Error('Missing authentication Token');
    }
    try {
        const url = `${constants_1.DATA_ENDPOINT}/${eventUrl}`;
        const response = await got_1.default.post(url, {
            agent: exports.DEFAULT_REQUEST_CONFIG.agent,
            headers: {
                ...exports.DEFAULT_REQUEST_CONFIG.headers,
                'Authorization': `Bearer ${jwtToken}`
            },
            json: data
        }).json();
        log.debug(`[${kind}] Success response: ${JSON.stringify(response)}`);
    }
    catch (error) {
        log.debug(`[${kind}] EXCEPTION IN ${kind} REQUEST TO TEST OBSERVABILITY : ${error}`);
        throw new Error('Exception in request ' + error);
    }
}
exports.batchAndPostEvents = batchAndPostEvents;
function getObservabilityUser(options, config) {
    if (process.env.BROWSERSTACK_USERNAME) {
        return process.env.BROWSERSTACK_USERNAME;
    }
    if (options.testObservabilityOptions && options.testObservabilityOptions.user) {
        return options.testObservabilityOptions.user;
    }
    return config.user;
}
exports.getObservabilityUser = getObservabilityUser;
function getObservabilityKey(options, config) {
    if (process.env.BROWSERSTACK_ACCESS_KEY) {
        return process.env.BROWSERSTACK_ACCESS_KEY;
    }
    if (options.testObservabilityOptions && options.testObservabilityOptions.key) {
        return options.testObservabilityOptions.key;
    }
    return config.key;
}
exports.getObservabilityKey = getObservabilityKey;
function getObservabilityProject(options, bstackProjectName) {
    if (process.env.TEST_OBSERVABILITY_PROJECT_NAME) {
        return process.env.TEST_OBSERVABILITY_PROJECT_NAME;
    }
    if (options.testObservabilityOptions && options.testObservabilityOptions.projectName) {
        return options.testObservabilityOptions.projectName;
    }
    return bstackProjectName;
}
exports.getObservabilityProject = getObservabilityProject;
function getObservabilityBuild(options, bstackBuildName) {
    if (process.env.TEST_OBSERVABILITY_BUILD_NAME) {
        return process.env.TEST_OBSERVABILITY_BUILD_NAME;
    }
    if (options.testObservabilityOptions && options.testObservabilityOptions.buildName) {
        return options.testObservabilityOptions.buildName;
    }
    return bstackBuildName || path_1.default.basename(path_1.default.resolve(process.cwd()));
}
exports.getObservabilityBuild = getObservabilityBuild;
function getObservabilityBuildTags(options, bstackBuildTag) {
    if (process.env.TEST_OBSERVABILITY_BUILD_TAG) {
        return process.env.TEST_OBSERVABILITY_BUILD_TAG.split(',');
    }
    if (options.testObservabilityOptions && options.testObservabilityOptions.buildTag) {
        return options.testObservabilityOptions.buildTag;
    }
    if (bstackBuildTag) {
        return [bstackBuildTag];
    }
    return [];
}
exports.getObservabilityBuildTags = getObservabilityBuildTags;
function frameworkSupportsHook(hook, framework) {
    if (framework === 'mocha' && (hook === 'before' || hook === 'after' || hook === 'beforeEach' || hook === 'afterEach')) {
        return true;
    }
    if (framework === 'cucumber') {
        return true;
    }
    return false;
}
exports.frameworkSupportsHook = frameworkSupportsHook;
function getFailureObject(error) {
    const stack = error.stack;
    const message = typeof error === 'string' ? error : error.message;
    const backtrace = stack ? removeAnsiColors(stack.toString()) : '';
    return {
        failure: [{ backtrace: [backtrace] }],
        failure_reason: removeAnsiColors(message.toString()),
        failure_type: message ? (message.toString().match(/AssertionError/) ? 'AssertionError' : 'UnhandledError') : null
    };
}
exports.getFailureObject = getFailureObject;
function patchConsoleLogs() {
    const BSTestOpsPatcher = new logPatcher_1.default({});
    Object.keys(constants_1.consoleHolder).forEach((method) => {
        const origMethod = console[method].bind(console);
        // Make sure we don't override Constructors
        // Arrow functions are not construable
        if (typeof console[method] === 'function'
            && method !== 'Console') {
            console[method] = (...args) => {
                origMethod(...args);
                BSTestOpsPatcher[method](...args);
            };
        }
    });
}
exports.patchConsoleLogs = patchConsoleLogs;
const sleep = (ms = 100) => new Promise((resolve) => setTimeout(resolve, ms));
exports.sleep = sleep;
const validateCapsWithA11y = (deviceName, platformMeta, chromeOptions) => {
    var _a, _b;
    try {
        if (deviceName) {
            log.warn('Accessibility Automation will run only on Desktop browsers.');
            return false;
        }
        if (((_a = platformMeta === null || platformMeta === void 0 ? void 0 : platformMeta.browser_name) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== 'chrome') {
            log.warn('Accessibility Automation will run only on Chrome browsers.');
            return false;
        }
        const browserVersion = platformMeta === null || platformMeta === void 0 ? void 0 : platformMeta.browser_version;
        if (!isUndefined(browserVersion) && !(browserVersion === 'latest' || parseFloat(browserVersion + '') > 94)) {
            log.warn('Accessibility Automation will run only on Chrome browser version greater than 94.');
            return false;
        }
        if ((_b = chromeOptions === null || chromeOptions === void 0 ? void 0 : chromeOptions.args) === null || _b === void 0 ? void 0 : _b.includes('--headless')) {
            log.warn('Accessibility Automation will not run on legacy headless mode. Switch to new headless mode or avoid using headless mode.');
            return false;
        }
        return true;
    }
    catch (error) {
        log.debug(`Exception in checking capabilities compatibility with Accessibility. Error: ${error}`);
    }
    return false;
};
exports.validateCapsWithA11y = validateCapsWithA11y;
const shouldScanTestForAccessibility = (suiteTitle, testTitle, accessibilityOptions) => {
    try {
        const includeTags = Array.isArray(accessibilityOptions === null || accessibilityOptions === void 0 ? void 0 : accessibilityOptions.includeTagsInTestingScope) ? accessibilityOptions === null || accessibilityOptions === void 0 ? void 0 : accessibilityOptions.includeTagsInTestingScope : [];
        const excludeTags = Array.isArray(accessibilityOptions === null || accessibilityOptions === void 0 ? void 0 : accessibilityOptions.excludeTagsInTestingScope) ? accessibilityOptions === null || accessibilityOptions === void 0 ? void 0 : accessibilityOptions.excludeTagsInTestingScope : [];
        const fullTestName = suiteTitle + ' ' + testTitle;
        const excluded = excludeTags === null || excludeTags === void 0 ? void 0 : excludeTags.some((exclude) => fullTestName.includes(exclude));
        const included = (includeTags === null || includeTags === void 0 ? void 0 : includeTags.length) === 0 || (includeTags === null || includeTags === void 0 ? void 0 : includeTags.some((include) => fullTestName.includes(include)));
        return !excluded && included;
    }
    catch (error) {
        log.debug('Error while validating test case for accessibility before scanning. Error : ', error);
    }
    return false;
};
exports.shouldScanTestForAccessibility = shouldScanTestForAccessibility;
const isAccessibilityAutomationSession = (accessibilityFlag) => {
    try {
        const hasA11yJwtToken = typeof process.env.BSTACK_A11Y_JWT === 'string' && process.env.BSTACK_A11Y_JWT.length > 0 && process.env.BSTACK_A11Y_JWT !== 'null' && process.env.BSTACK_A11Y_JWT !== 'undefined';
        return accessibilityFlag && hasA11yJwtToken;
    }
    catch (error) {
        log.debug(`Exception in verifying the Accessibility session with error : ${error}`);
    }
    return false;
};
exports.isAccessibilityAutomationSession = isAccessibilityAutomationSession;
exports.createAccessibilityTestRun = errorHandler(async function createAccessibilityTestRun(options, config, bsConfig) {
    const userName = getBrowserStackUser(config);
    const accessKey = getBrowserStackKey(config);
    if (isUndefined(userName) || isUndefined(accessKey)) {
        log.error('Exception while creating test run for BrowserStack Accessibility Automation: Missing BrowserStack credentials');
        return null;
    }
    const data = {
        'projectName': bsConfig.projectName,
        'buildName': bsConfig.buildName ||
            path_1.default.basename(path_1.default.resolve(process.cwd())),
        'startTime': (new Date()).toISOString(),
        'description': '',
        'source': {
            frameworkName: 'WebdriverIO-' + config.framework,
            frameworkVersion: bsConfig.bstackServiceVersion,
            sdkVersion: bsConfig.bstackServiceVersion,
            language: 'ECMAScript',
            testFramework: 'webdriverIO',
            testFrameworkVersion: bsConfig.bstackServiceVersion
        },
        'settings': bsConfig.accessibilityOptions || {},
        'versionControl': await getGitMetaData(),
        'ciInfo': getCiInfo(),
        'hostInfo': {
            hostname: (0, os_1.hostname)(),
            platform: (0, os_1.platform)(),
            type: (0, os_1.type)(),
            version: (0, os_1.version)(),
            arch: (0, os_1.arch)()
        },
        'browserstackAutomation': true,
    };
    const requestOptions = {
        json: data,
        username: getBrowserStackUser(config),
        password: getBrowserStackKey(config),
    };
    try {
        const response = await nodeRequest('POST', 'v2/test_runs', requestOptions, constants_1.ACCESSIBILITY_API_URL);
        log.debug(`[Create Accessibility Test Run] Success response: ${JSON.stringify(response)}`);
        if (response.data.accessibilityToken) {
            process.env.BSTACK_A11Y_JWT = response.data.accessibilityToken;
        }
        if (response.data.id) {
            process.env.BS_A11Y_TEST_RUN_ID = response.data.id;
        }
        log.debug(`BrowserStack Accessibility Automation Test Run ID: ${response.data.id}`);
        if (response.data) {
            accessibility_scripts_1.default.update(response.data);
            accessibility_scripts_1.default.store();
        }
        return response.data.scannerVersion;
    }
    catch (error) {
        if (error.response) {
            log.error(`Exception while creating test run for BrowserStack Accessibility Automation: ${error.response.status} ${error.response.statusText} ${JSON.stringify(error.response.data)}`);
        }
        else {
            const errorMessage = error.message;
            if (errorMessage === 'Invalid configuration passed.') {
                log.error(`Exception while creating test run for BrowserStack Accessibility Automation: ${errorMessage || error.stack}`);
                for (const errorkey of error.errors) {
                    log.error(errorkey.message);
                }
            }
            else {
                log.error(`Exception while creating test run for BrowserStack Accessibility Automation: ${errorMessage || error.stack}`);
            }
        }
        return null;
    }
});
const performA11yScan = async (browser, isBrowserStackSession, isAccessibility, commandName) => {
    if (!isBrowserStackSession) {
        log.warn('Not a BrowserStack Automate session, cannot perform Accessibility scan.');
        return; // since we are running only on Automate as of now
    }
    if (!(0, exports.isAccessibilityAutomationSession)(isAccessibility)) {
        log.warn('Not an Accessibility Automation session, cannot perform Accessibility scan.');
        return;
    }
    try {
        const results = await browser.executeAsync(accessibility_scripts_1.default.performScan, { 'method': commandName || '' });
        log.debug(util_2.default.format(results));
        return results;
    }
    catch (err) {
        log.error('Accessibility Scan could not be performed : ' + err);
        return;
    }
};
exports.performA11yScan = performA11yScan;
const getA11yResults = async (browser, isBrowserStackSession, isAccessibility) => {
    if (!isBrowserStackSession) {
        log.warn('Not a BrowserStack Automate session, cannot retrieve Accessibility results.');
        return []; // since we are running only on Automate as of now
    }
    if (!(0, exports.isAccessibilityAutomationSession)(isAccessibility)) {
        log.warn('Not an Accessibility Automation session, cannot retrieve Accessibility results.');
        return [];
    }
    try {
        log.debug('Performing scan before getting results');
        await (0, exports.performA11yScan)(browser, isBrowserStackSession, isAccessibility);
        const results = await browser.executeAsync(accessibility_scripts_1.default.getResults);
        return results;
    }
    catch {
        log.error('No accessibility results were found.');
        return [];
    }
};
exports.getA11yResults = getA11yResults;
const getA11yResultsSummary = async (browser, isBrowserStackSession, isAccessibility) => {
    if (!isBrowserStackSession) {
        return {}; // since we are running only on Automate as of now
    }
    if (!(0, exports.isAccessibilityAutomationSession)(isAccessibility)) {
        log.warn('Not an Accessibility Automation session, cannot retrieve Accessibility results summary.');
        return {};
    }
    try {
        log.debug('Performing scan before getting results summary');
        await (0, exports.performA11yScan)(browser, isBrowserStackSession, isAccessibility);
        const summaryResults = await browser.executeAsync(accessibility_scripts_1.default.getResultsSummary);
        return summaryResults;
    }
    catch {
        log.error('No accessibility summary was found.');
        return {};
    }
};
exports.getA11yResultsSummary = getA11yResultsSummary;
exports.stopAccessibilityTestRun = errorHandler(async function stopAccessibilityTestRun() {
    const hasA11yJwtToken = typeof process.env.BSTACK_A11Y_JWT === 'string' && process.env.BSTACK_A11Y_JWT.length > 0 && process.env.BSTACK_A11Y_JWT !== 'null' && process.env.BSTACK_A11Y_JWT !== 'undefined';
    if (!hasA11yJwtToken) {
        return {
            status: 'error',
            message: 'Build creation had failed.'
        };
    }
    const data = {
        'endTime': (new Date()).toISOString(),
    };
    const requestOptions = { ...{
            json: data,
            headers: {
                'Authorization': `Bearer ${process.env.BSTACK_A11Y_JWT}`,
            }
        } };
    try {
        const response = await nodeRequest('PUT', 'test_runs/stop', requestOptions, constants_1.ACCESSIBILITY_API_URL);
        if (response.data && response.data.error) {
            throw new Error('Invalid request: ' + response.data.error);
        }
        else if (response.error) {
            throw new Error('Invalid request: ' + response.error);
        }
        else {
            log.info(`BrowserStack Accessibility Automation Test Run marked as completed at ${new Date().toISOString()}`);
            return { status: 'success', message: '' };
        }
    }
    catch (error) {
        if (error.response && error.response.status && error.response.statusText && error.response.data) {
            log.error(`Exception while marking completion of BrowserStack Accessibility Automation Test Run: ${error.response.status} ${error.response.statusText} ${JSON.stringify(error.response.data)}`);
        }
        else {
            log.error(`Exception while marking completion of BrowserStack Accessibility Automation Test Run: ${error.message || util_2.default.format(error)}`);
        }
        return {
            status: 'error',
            message: error.message ||
                (error.response ? `${error.response.status}:${error.response.statusText}` : error)
        };
    }
});
function getBrowserStackUser(config) {
    if (process.env.BROWSERSTACK_USERNAME) {
        return process.env.BROWSERSTACK_USERNAME;
    }
    return config.user;
}
exports.getBrowserStackUser = getBrowserStackUser;
function getBrowserStackKey(config) {
    if (process.env.BROWSERSTACK_ACCESS_KEY) {
        return process.env.BROWSERSTACK_ACCESS_KEY;
    }
    return config.key;
}
exports.getBrowserStackKey = getBrowserStackKey;
function isUndefined(value) {
    return value === undefined || value === null;
}
exports.isUndefined = isUndefined;
function isTrue(value) {
    return (value + '').toLowerCase() === 'true';
}
exports.isTrue = isTrue;
const isObject = (object) => {
    return object !== null && typeof object === 'object' && !Array.isArray(object);
};
exports.isObject = isObject;
const ObjectsAreEqual = (object1, object2) => {
    const objectKeys1 = Object.keys(object1);
    const objectKeys2 = Object.keys(object2);
    if (objectKeys1.length !== objectKeys2.length) {
        return false;
    }
    for (const key of objectKeys1) {
        const value1 = object1[key];
        const value2 = object2[key];
        const isBothAreObjects = (0, exports.isObject)(value1) && (0, exports.isObject)(value2);
        if ((isBothAreObjects && !(0, exports.ObjectsAreEqual)(value1, value2)) || (!isBothAreObjects && value1 !== value2)) {
            return false;
        }
    }
    return true;
};
exports.ObjectsAreEqual = ObjectsAreEqual;
exports.getPlatformVersion = o11yErrorHandler(function getPlatformVersion(caps) {
    var _a;
    if (!caps) {
        return undefined;
    }
    const bstackOptions = (_a = (caps)) === null || _a === void 0 ? void 0 : _a['bstack:options'];
    const keys = ['platformVersion', 'platform_version', 'osVersion', 'os_version', 'appium:platformVersion'];
    for (const key of keys) {
        if (bstackOptions && (bstackOptions === null || bstackOptions === void 0 ? void 0 : bstackOptions[key])) {
            return String(bstackOptions === null || bstackOptions === void 0 ? void 0 : bstackOptions[key]);
        }
        else if (caps[key]) {
            return String(caps[key]);
        }
    }
    return undefined;
});
const isObjectEmpty = (objectName) => {
    return (objectName &&
        Object.keys(objectName).length === 0 &&
        objectName.constructor === Object);
};
exports.isObjectEmpty = isObjectEmpty;
const getErrorString = (err) => {
    if (!err) {
        return undefined;
    }
    if (typeof err === 'string') {
        return err; // works, `e` narrowed to string
    }
    else if (err instanceof Error) {
        return err.message; // works, `e` narrowed to Error
    }
};
exports.getErrorString = getErrorString;

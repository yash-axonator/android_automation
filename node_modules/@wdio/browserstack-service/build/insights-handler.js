"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const logger_1 = __importDefault(require("@wdio/logger"));
const uuid_1 = require("uuid");
const reporter_1 = __importDefault(require("./reporter"));
const util_1 = require("./util");
const listener_1 = __importDefault(require("./testOps/listener"));
const constants_1 = require("./constants");
const log = (0, logger_1.default)('@wdio/browserstack-service');
class _InsightsHandler {
    constructor(_browser, browserCaps, isAppAutomate, sessionId, _framework, _userCaps) {
        this._browser = _browser;
        this._framework = _framework;
        this._tests = {};
        this._hooks = {};
        this._commands = {};
        this._currentTest = {};
        this._currentHook = {};
        this._cucumberData = {
            stepsStarted: false,
            scenariosStarted: false,
            steps: []
        };
        this._userCaps = {};
        this.listener = listener_1.default.getInstance();
        this.appendTestItemLog = async (stdLog) => {
            try {
                if (this._currentHook.uuid && !this._currentHook.finished && (this._framework === 'mocha' || this._framework === 'cucumber')) {
                    stdLog.hook_run_uuid = this._currentHook.uuid;
                }
                else if (this._currentTest.uuid && (this._framework === 'mocha' || this._framework === 'cucumber')) {
                    stdLog.test_run_uuid = this._currentTest.uuid;
                }
                if (stdLog.hook_run_uuid || stdLog.test_run_uuid) {
                    this.listener.logCreated([stdLog]);
                }
            }
            catch (error) {
                log.debug(`Exception in uploading log data to Observability with error : ${error}`);
            }
        };
        this._platformMeta = {
            browserName: browserCaps === null || browserCaps === void 0 ? void 0 : browserCaps.browserName,
            browserVersion: browserCaps === null || browserCaps === void 0 ? void 0 : browserCaps.browserVersion,
            platformName: browserCaps === null || browserCaps === void 0 ? void 0 : browserCaps.platformName,
            caps: browserCaps,
            sessionId: sessionId,
            product: isAppAutomate ? 'app-automate' : 'automate'
        };
        this._userCaps = _userCaps;
        this.registerListeners();
    }
    registerListeners() {
        if (!(this._framework === 'mocha' || this._framework === 'cucumber')) {
            return;
        }
        process.removeAllListeners(`bs:addLog:${process.pid}`);
        process.on(`bs:addLog:${process.pid}`, this.appendTestItemLog.bind(this));
    }
    async before() {
        if ((0, util_1.isBrowserstackSession)(this._browser)) {
            await this._browser.execute(`browserstack_executor: {"action": "annotate", "arguments": {"data": "ObservabilitySync:${Date.now()}","level": "debug"}}`);
        }
        const gitMeta = await (0, util_1.getGitMetaData)();
        if (gitMeta) {
            this._gitConfigPath = gitMeta.root;
        }
    }
    async beforeHook(test, context) {
        if (!(0, util_1.frameworkSupportsHook)('before', this._framework)) {
            return;
        }
        const hookUUID = (0, uuid_1.v4)();
        if (this._framework === 'cucumber') {
            test = test;
            await this.processCucumberHook(test, { event: 'before', hookUUID });
            return;
        }
        test = test;
        const fullTitle = (0, util_1.getUniqueIdentifier)(test, this._framework);
        this._tests[fullTitle] = {
            uuid: hookUUID,
            startedAt: (new Date()).toISOString()
        };
        this.setCurrentHook({ uuid: hookUUID });
        this.attachHookData(context, hookUUID);
        this.listener.hookStarted(this.getRunData(test, 'HookRunStarted'));
    }
    async afterHook(test, result) {
        if (!(0, util_1.frameworkSupportsHook)('after', this._framework)) {
            return;
        }
        if (this._framework === 'cucumber') {
            await this.processCucumberHook(test, { event: 'after' }, result);
            return;
        }
        test = test;
        const fullTitle = (0, util_1.getUniqueIdentifier)(test, this._framework);
        if (this._tests[fullTitle]) {
            this._tests[fullTitle].finishedAt = (new Date()).toISOString();
        }
        else {
            this._tests[fullTitle] = {
                finishedAt: (new Date()).toISOString()
            };
        }
        this.setCurrentHook({ uuid: this._tests[fullTitle].uuid, finished: true });
        this.listener.hookFinished(this.getRunData(test, 'HookRunFinished', result));
        const hookType = (0, util_1.getHookType)(test.title);
        /*
            If any of the `beforeAll`, `beforeEach`, `afterEach` then the tests after the hook won't run in mocha (https://github.com/mochajs/mocha/issues/4392)
            So if any of this hook fails, then we are sending the next tests in the suite as skipped.
            This won't be needed for `afterAll`, as even if `afterAll` fails all the tests that we need are already run by then, so we don't need to send the stats for them separately
         */
        if (!result.passed && (hookType === 'BEFORE_EACH' || hookType === 'BEFORE_ALL' || hookType === 'AFTER_EACH')) {
            const sendTestSkip = async (skippedTest) => {
                // We only need to send the tests that whose state is not determined yet. The state of tests which is determined will already be sent.
                if (skippedTest.state === undefined) {
                    const fullTitle = `${skippedTest.parent.title} - ${skippedTest.title}`;
                    this._tests[fullTitle] = {
                        uuid: (0, uuid_1.v4)(),
                        startedAt: (new Date()).toISOString(),
                        finishedAt: (new Date()).toISOString()
                    };
                    this.listener.testFinished(this.getRunData(skippedTest, 'TestRunSkipped'));
                }
            };
            /*
                Recursively send the tests as skipped for all suites below the hook. This is to handle nested describe blocks
             */
            const sendSuiteSkipped = async (suite) => {
                for (const skippedTest of suite.tests) {
                    await sendTestSkip(skippedTest);
                }
                for (const skippedSuite of suite.suites) {
                    await sendSuiteSkipped(skippedSuite);
                }
            };
            await sendSuiteSkipped(test.ctx.test.parent);
        }
    }
    async beforeTest(test) {
        const uuid = (0, uuid_1.v4)();
        this._currentTest = {
            test, uuid
        };
        if (this._framework !== 'mocha')
            return;
        const fullTitle = (0, util_1.getUniqueIdentifier)(test, this._framework);
        this._tests[fullTitle] = {
            uuid: uuid,
            startedAt: (new Date()).toISOString()
        };
        this.listener.testStarted(this.getRunData(test, 'TestRunStarted'));
    }
    async afterTest(test, result) {
        if (this._framework !== 'mocha')
            return;
        const fullTitle = (0, util_1.getUniqueIdentifier)(test, this._framework);
        this._tests[fullTitle] = {
            ...(this._tests[fullTitle] || {}),
            finishedAt: (new Date()).toISOString()
        };
        this.listener.testFinished(this.getRunData(test, 'TestRunFinished', result));
    }
    /**
      * Cucumber Only
      */
    async beforeFeature(uri, feature) {
        this._cucumberData.scenariosStarted = false;
        this._cucumberData.feature = feature;
        this._cucumberData.uri = uri;
    }
    async beforeScenario(world) {
        const uuid = (0, uuid_1.v4)();
        this._currentTest = {
            uuid
        };
        this._cucumberData.scenario = world.pickle;
        this._cucumberData.scenariosStarted = true;
        this._cucumberData.stepsStarted = false;
        const pickleData = world.pickle;
        const gherkinDocument = world.gherkinDocument;
        const featureData = gherkinDocument.feature;
        const uniqueId = (0, util_1.getUniqueIdentifierForCucumber)(world);
        let testMetaData = {
            uuid: uuid,
            startedAt: (new Date()).toISOString()
        };
        if (pickleData) {
            testMetaData.scenario = {
                name: pickleData.name,
            };
        }
        if (gherkinDocument && featureData) {
            testMetaData.feature = {
                path: gherkinDocument.uri,
                name: featureData.name,
                description: featureData.description,
            };
        }
        this._tests[uniqueId] = testMetaData;
        this.listener.testStarted(this.getTestRunDataForCucumber(world, 'TestRunStarted'));
    }
    async afterScenario(world) {
        this._cucumberData.scenario = undefined;
        this.listener.testFinished(this.getTestRunDataForCucumber(world, 'TestRunFinished'));
    }
    async beforeStep(step, scenario) {
        var _a;
        this._cucumberData.stepsStarted = true;
        this._cucumberData.steps.push(step);
        const uniqueId = (0, util_1.getUniqueIdentifierForCucumber)({ pickle: scenario });
        let testMetaData = this._tests[uniqueId];
        if (!testMetaData) {
            testMetaData = {
                steps: []
            };
        }
        if (testMetaData && !testMetaData.steps) {
            testMetaData.steps = [];
        }
        (_a = testMetaData.steps) === null || _a === void 0 ? void 0 : _a.push({
            id: step.id,
            text: step.text,
            keyword: step.keyword,
            started_at: (new Date()).toISOString()
        });
        this._tests[uniqueId] = testMetaData;
    }
    async afterStep(step, scenario, result) {
        var _a;
        this._cucumberData.steps.pop();
        const uniqueId = (0, util_1.getUniqueIdentifierForCucumber)({ pickle: scenario });
        let testMetaData = this._tests[uniqueId];
        if (!testMetaData) {
            testMetaData = {
                steps: []
            };
        }
        if (!testMetaData.steps) {
            testMetaData.steps = [{
                    id: step.id,
                    text: step.text,
                    keyword: step.keyword,
                    finished_at: (new Date()).toISOString(),
                    result: result.passed ? 'PASSED' : 'FAILED',
                    duration: result.duration,
                    failure: result.error ? (0, util_1.removeAnsiColors)(result.error) : result.error
                }];
        }
        const stepDetails = (_a = testMetaData.steps) === null || _a === void 0 ? void 0 : _a.find(item => item.id == step.id);
        if (stepDetails) {
            stepDetails.finished_at = (new Date()).toISOString();
            stepDetails.result = result.passed ? 'PASSED' : 'FAILED';
            stepDetails.duration = result.duration;
            stepDetails.failure = result.error ? (0, util_1.removeAnsiColors)(result.error) : result.error;
        }
        this._tests[uniqueId] = testMetaData;
    }
    async sendScenarioObjectSkipped(scenario, feature, uri) {
        const testMetaData = {
            uuid: (0, uuid_1.v4)(),
            startedAt: (new Date()).toISOString(),
            finishedAt: (new Date()).toISOString(),
            scenario: {
                name: scenario.name
            },
            feature: {
                path: uri,
                name: feature.name,
                description: feature.description
            },
            steps: scenario.steps.map((step) => {
                return {
                    id: step.id,
                    text: step.text,
                    keyword: step.keyword,
                    result: 'skipped',
                };
            }),
        };
        this.listener.testFinished(this.getTestRunDataForCucumber(null, 'TestRunSkipped', testMetaData));
    }
    async processCucumberHook(test, params, result) {
        const hookType = this.getCucumberHookType(test);
        if (!hookType) {
            return;
        }
        const { event, hookUUID } = params;
        const hookId = this.getCucumberHookUniqueId(hookType, test);
        if (!hookId) {
            return;
        }
        if (event === 'before') {
            this.setCurrentHook({ uuid: hookUUID });
            const hookMetaData = {
                uuid: hookUUID,
                startedAt: (new Date()).toISOString(),
                testRunId: this._currentTest.uuid,
                hookType: hookType
            };
            this._tests[hookId] = hookMetaData;
            this.listener.hookStarted(this.getHookRunDataForCucumber(hookMetaData, 'HookRunStarted'));
        }
        else {
            this._tests[hookId].finishedAt = (new Date()).toISOString();
            this.setCurrentHook({ uuid: this._tests[hookId].uuid, finished: true });
            this.listener.hookFinished(this.getHookRunDataForCucumber(this._tests[hookId], 'HookRunFinished', result));
            if (hookType === 'BEFORE_ALL' && result && !result.passed) {
                const { feature, uri } = this._cucumberData;
                if (!feature) {
                    return;
                }
                feature.children.map(async (childObj) => {
                    if (childObj.rule) {
                        childObj.rule.children.map(async (scenarioObj) => {
                            if (scenarioObj.scenario) {
                                await this.sendScenarioObjectSkipped(scenarioObj.scenario, feature, uri);
                            }
                        });
                    }
                    else if (childObj.scenario) {
                        await this.sendScenarioObjectSkipped(childObj.scenario, feature, uri);
                    }
                });
            }
        }
    }
    async browserCommand(commandType, args, test) {
        if (commandType === 'client:beforeCommand') {
            this._commands[`${args.sessionId}_${args.method}_${args.endpoint}`] = args;
            return;
        }
        if (!test) {
            return;
        }
        const identifier = this.getIdentifier(test);
        const testMeta = this._tests[identifier] || reporter_1.default.getTests()[identifier];
        if (!testMeta) {
            return;
        }
        // log screenshot
        if (Boolean(process.env[constants_1.TESTOPS_SCREENSHOT_ENV]) && (0, util_1.isScreenshotCommand)(args) && args.result.value) {
            await this.listener.onScreenshot([{
                    test_run_uuid: testMeta.uuid,
                    timestamp: new Date().toISOString(),
                    message: args.result.value,
                    kind: 'TEST_SCREENSHOT'
                }]);
        }
        const dataKey = `${args.sessionId}_${args.method}_${args.endpoint}`;
        const requestData = this._commands[dataKey];
        if (!requestData) {
            return;
        }
        // log http request
        this.listener.logCreated([{
                test_run_uuid: testMeta.uuid,
                timestamp: new Date().toISOString(),
                kind: 'HTTP',
                http_response: {
                    path: requestData.endpoint,
                    method: requestData.method,
                    body: requestData.body,
                    response: args.result
                }
            }]);
    }
    attachHookData(context, hookId) {
        if (context.currentTest && context.currentTest.parent) {
            const parentTest = `${context.currentTest.parent.title} - ${context.currentTest.title}`;
            if (!this._hooks[parentTest]) {
                this._hooks[parentTest] = [];
            }
            this._hooks[parentTest].push(hookId);
            return;
        }
        else if (context.test) {
            this.setHooksFromSuite(context.test.parent, hookId);
        }
    }
    setHooksFromSuite(parent, hookId) {
        if (!parent) {
            return false;
        }
        if (parent.tests && parent.tests.length > 0) {
            const uniqueIdentifier = (0, util_1.getUniqueIdentifier)(parent.tests[0], this._framework);
            if (!this._hooks[uniqueIdentifier]) {
                this._hooks[uniqueIdentifier] = [];
            }
            this._hooks[uniqueIdentifier].push(hookId);
            return true;
        }
        for (const suite of parent.suites) {
            const result = this.setHooksFromSuite(suite, hookId);
            if (result) {
                return true;
            }
        }
        return false;
    }
    getCucumberHookType(test) {
        var _a;
        let hookType = null;
        if (!test) {
            hookType = this._cucumberData.scenariosStarted ? 'AFTER_ALL' : 'BEFORE_ALL';
        }
        else if (!this._cucumberData.stepsStarted) {
            hookType = 'BEFORE_EACH';
        }
        else if (((_a = this._cucumberData.steps) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            // beforeStep or afterStep
        }
        else {
            hookType = 'AFTER_EACH';
        }
        return hookType;
    }
    getCucumberHookName(hookType) {
        var _a, _b;
        switch (hookType) {
            case 'BEFORE_EACH':
            case 'AFTER_EACH':
                return `${hookType} for ${(_a = this._cucumberData.scenario) === null || _a === void 0 ? void 0 : _a.name}`;
            case 'BEFORE_ALL':
            case 'AFTER_ALL':
                return `${hookType} for ${(_b = this._cucumberData.feature) === null || _b === void 0 ? void 0 : _b.name}`;
        }
        return '';
    }
    getCucumberHookUniqueId(hookType, hook) {
        switch (hookType) {
            case 'BEFORE_EACH':
            case 'AFTER_EACH':
                return hook.hookId;
            case 'BEFORE_ALL':
            case 'AFTER_ALL':
                // Can only work for single beforeAll or afterAll
                return `${hookType} for ${this.getCucumberFeatureUniqueId()}`;
        }
        return null;
    }
    getCucumberFeatureUniqueId() {
        const { uri, feature } = this._cucumberData;
        return `${uri}:${feature === null || feature === void 0 ? void 0 : feature.name}`;
    }
    setCurrentHook(hookDetails) {
        if (hookDetails.finished) {
            if (this._currentHook.uuid === hookDetails.uuid) {
                this._currentHook.finished = true;
            }
            return;
        }
        this._currentHook = {
            uuid: hookDetails.uuid,
            finished: false
        };
    }
    /*
     * Get hierarchy info
     */
    getHierarchy(test) {
        const value = [];
        if (test.ctx && test.ctx.test) {
            // If we already have the parent object, utilize it else get from context
            let parent = typeof test.parent === 'object' ? test.parent : test.ctx.test.parent;
            while (parent && parent.title !== '') {
                value.push(parent.title);
                parent = parent.parent;
            }
        }
        return value.reverse();
    }
    getTestRunId(context) {
        if (!context) {
            return;
        }
        if (context.currentTest) {
            const uniqueIdentifier = (0, util_1.getUniqueIdentifier)(context.currentTest, this._framework);
            return this._tests[uniqueIdentifier] && this._tests[uniqueIdentifier].uuid;
        }
        if (!context.test) {
            return;
        }
        return this.getTestRunIdFromSuite(context.test.parent);
    }
    getTestRunIdFromSuite(parent) {
        if (!parent) {
            return;
        }
        for (const test of parent.tests) {
            const uniqueIdentifier = (0, util_1.getUniqueIdentifier)(test, this._framework);
            if (this._tests[uniqueIdentifier]) {
                return this._tests[uniqueIdentifier].uuid;
            }
        }
        for (const suite of parent.suites) {
            const testRunId = this.getTestRunIdFromSuite(suite);
            if (testRunId) {
                return testRunId;
            }
        }
        return;
    }
    getRunData(test, eventType, results) {
        var _a;
        const fullTitle = (0, util_1.getUniqueIdentifier)(test, this._framework);
        const testMetaData = this._tests[fullTitle];
        const testData = {
            uuid: testMetaData.uuid,
            type: test.type,
            name: test.title,
            body: {
                lang: 'webdriverio',
                code: test.body
            },
            scope: fullTitle,
            scopes: this.getHierarchy(test),
            identifier: fullTitle,
            file_name: test.file ? path_1.default.relative(process.cwd(), test.file) : undefined,
            location: test.file ? path_1.default.relative(process.cwd(), test.file) : undefined,
            vc_filepath: (this._gitConfigPath && test.file) ? path_1.default.relative(this._gitConfigPath, test.file) : undefined,
            started_at: testMetaData.startedAt,
            finished_at: testMetaData.finishedAt,
            result: 'pending',
            framework: this._framework
        };
        if ((eventType == 'TestRunFinished' || eventType == 'HookRunFinished') && results) {
            const { error, passed } = results;
            if (!passed) {
                testData.result = (error && error.message && error.message.includes('sync skip; aborting execution')) ? 'ignore' : 'failed';
                if (error && testData.result != 'skipped') {
                    testData.failure = [{ backtrace: [(0, util_1.removeAnsiColors)(error.message)] }]; // add all errors here
                    testData.failure_reason = (0, util_1.removeAnsiColors)(error.message);
                    testData.failure_type = error.message == null ? null : error.message.toString().match(/AssertionError/) ? 'AssertionError' : 'UnhandledError'; //verify if this is working
                }
            }
            else {
                testData.result = 'passed';
            }
            testData.retries = results.retries;
            testData.duration_in_ms = results.duration;
            if (this._hooks[fullTitle]) {
                testData.hooks = this._hooks[fullTitle];
            }
        }
        if (eventType === 'TestRunStarted' || eventType === 'TestRunSkipped' || eventType === 'HookRunStarted') {
            testData.integrations = {};
            if (this._browser && this._platformMeta) {
                const provider = (0, util_1.getCloudProvider)(this._browser);
                testData.integrations[provider] = this.getIntegrationsObject();
            }
        }
        if (eventType === 'TestRunSkipped') {
            testData.result = 'skipped';
            eventType = 'TestRunFinished';
        }
        /* istanbul ignore if */
        if (eventType.match(/HookRun/)) {
            testData.hook_type = ((_a = testData.name) === null || _a === void 0 ? void 0 : _a.toLowerCase()) ? (0, util_1.getHookType)(testData.name.toLowerCase()) : 'undefined';
            testData.test_run_id = this.getTestRunId(test.ctx);
        }
        return testData;
    }
    getTestRunDataForCucumber(worldObj, eventType, testMetaData = null) {
        const world = worldObj;
        const dataHub = testMetaData ? testMetaData : (this._tests[(0, util_1.getUniqueIdentifierForCucumber)(world)] || {});
        const { feature, scenario, steps, uuid, startedAt, finishedAt } = dataHub;
        const examples = !testMetaData ? (0, util_1.getScenarioExamples)(world) : undefined;
        let fullNameWithExamples;
        if (!testMetaData) {
            fullNameWithExamples = examples
                ? world.pickle.name + ' (' + examples.join(', ') + ')'
                : world.pickle.name;
        }
        else {
            fullNameWithExamples = (scenario === null || scenario === void 0 ? void 0 : scenario.name) || '';
        }
        let testData = {
            uuid: uuid,
            started_at: startedAt,
            finished_at: finishedAt,
            type: 'test',
            body: {
                lang: 'webdriverio',
                code: null
            },
            name: fullNameWithExamples,
            scope: fullNameWithExamples,
            scopes: [(feature === null || feature === void 0 ? void 0 : feature.name) || ''],
            identifier: scenario === null || scenario === void 0 ? void 0 : scenario.name,
            file_name: feature && feature.path ? path_1.default.relative(process.cwd(), feature.path) : undefined,
            location: feature && feature.path ? path_1.default.relative(process.cwd(), feature.path) : undefined,
            vc_filepath: (this._gitConfigPath && (feature === null || feature === void 0 ? void 0 : feature.path)) ? path_1.default.relative(this._gitConfigPath, feature === null || feature === void 0 ? void 0 : feature.path) : undefined,
            framework: this._framework,
            result: 'pending',
            meta: {
                feature: feature,
                scenario: scenario,
                steps: steps,
                examples: examples
            }
        };
        if (eventType == 'TestRunStarted' || eventType === 'TestRunSkipped') {
            testData.integrations = {};
            if (this._browser && this._platformMeta) {
                const provider = (0, util_1.getCloudProvider)(this._browser);
                testData.integrations[provider] = this.getIntegrationsObject();
            }
        }
        /* istanbul ignore if */
        if (world === null || world === void 0 ? void 0 : world.result) {
            let result = world.result.status.toLowerCase();
            if (result !== 'passed' && result !== 'failed') {
                result = 'skipped'; // mark UNKNOWN/UNDEFINED/AMBIGUOUS/PENDING as skipped
            }
            testData.finished_at = (new Date()).toISOString();
            testData.result = result;
            testData.duration_in_ms = world.result.duration.nanos / 1000000; // send duration in ms
            if (result === 'failed') {
                testData.failure = [
                    {
                        'backtrace': [world.result.message ? (0, util_1.removeAnsiColors)(world.result.message) : 'unknown']
                    }
                ];
                testData.failure_reason = world.result.message ? (0, util_1.removeAnsiColors)(world.result.message) : world.result.message;
                if (world.result.message) {
                    testData.failure_type = world.result.message.match(/AssertionError/)
                        ? 'AssertionError'
                        : 'UnhandledError';
                }
            }
        }
        if (world === null || world === void 0 ? void 0 : world.pickle) {
            testData.tags = world.pickle.tags.map(({ name }) => (name));
        }
        if (eventType === 'TestRunSkipped') {
            testData.result = 'skipped';
        }
        return testData;
    }
    getHookRunDataForCucumber(hookData, eventType, result) {
        const { uri, feature } = this._cucumberData;
        const testData = {
            uuid: hookData.uuid,
            type: 'hook',
            name: this.getCucumberHookName(hookData.hookType),
            body: {
                lang: 'webdriverio',
                code: null
            },
            started_at: hookData.startedAt,
            finished_at: hookData.finishedAt,
            hook_type: hookData.hookType,
            test_run_id: hookData.testRunId,
            scope: feature === null || feature === void 0 ? void 0 : feature.name,
            scopes: [(feature === null || feature === void 0 ? void 0 : feature.name) || ''],
            file_name: uri ? path_1.default.relative(process.cwd(), uri) : undefined,
            location: uri ? path_1.default.relative(process.cwd(), uri) : undefined,
            vc_filepath: (this._gitConfigPath && uri) ? path_1.default.relative(this._gitConfigPath, uri) : undefined,
            result: 'pending',
            framework: this._framework
        };
        if (eventType === 'HookRunFinished' && result) {
            testData.result = result.passed ? 'passed' : 'failed';
            testData.retries = result.retries;
            testData.duration_in_ms = result.duration;
            if (!result.passed) {
                Object.assign(testData, (0, util_1.getFailureObject)(result.error));
            }
        }
        if (eventType === 'HookRunStarted') {
            testData.integrations = {};
            if (this._browser && this._platformMeta) {
                const provider = (0, util_1.getCloudProvider)(this._browser);
                testData.integrations[provider] = this.getIntegrationsObject();
            }
        }
        return testData;
    }
    getIntegrationsObject() {
        var _a, _b;
        const browserCaps = this._browser.capabilities;
        return {
            capabilities: browserCaps,
            session_id: (_a = this._browser) === null || _a === void 0 ? void 0 : _a.sessionId,
            browser: browserCaps === null || browserCaps === void 0 ? void 0 : browserCaps.browserName,
            browser_version: browserCaps === null || browserCaps === void 0 ? void 0 : browserCaps.browserVersion,
            platform: browserCaps === null || browserCaps === void 0 ? void 0 : browserCaps.platformName,
            product: (_b = this._platformMeta) === null || _b === void 0 ? void 0 : _b.product,
            platform_version: (0, util_1.getPlatformVersion)(this._userCaps)
        };
    }
    getIdentifier(test) {
        if ('pickle' in test) {
            return (0, util_1.getUniqueIdentifierForCucumber)(test);
        }
        return (0, util_1.getUniqueIdentifier)(test, this._framework);
    }
}
// https://github.com/microsoft/TypeScript/issues/6543
const InsightsHandler = (0, util_1.o11yClassErrorHandler)(_InsightsHandler);
exports.default = InsightsHandler;

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("@wdio/logger"));
const constants_1 = require("./constants");
const bstackLogger_1 = require("./bstackLogger");
const log = (0, logger_1.default)('@wdio/browserstack-service');
class RequestQueueHandler {
    // making it private to use singleton pattern
    constructor(callback) {
        this.queue = [];
        this.tearDownInvoked = false;
        this.callCallback = async (data, kind) => {
            bstackLogger_1.BStackLogger.debug('calling callback with kind ' + kind);
            this.callback && await this.callback(data);
        };
        this.callback = callback;
        this.startEventBatchPolling();
    }
    static getInstance(callback) {
        if (!RequestQueueHandler.instance && callback) {
            RequestQueueHandler.instance = new RequestQueueHandler(callback);
        }
        return RequestQueueHandler.instance;
    }
    add(event) {
        if (!process.env[constants_1.TESTOPS_BUILD_COMPLETED_ENV]) {
            throw new Error('Observability build start not completed yet.');
        }
        this.queue.push(event);
        bstackLogger_1.BStackLogger.debug(`Added data to request queue. Queue length = ${this.queue.length}`);
        const shouldProceed = this.shouldProceed();
        if (shouldProceed) {
            this.sendBatch().catch((e) => {
                bstackLogger_1.BStackLogger.debug('Exception in sending batch: ' + e);
            });
        }
    }
    async shutdown() {
        this.removeEventBatchPolling('Shutting down');
        while (this.queue.length > 0) {
            const data = this.queue.splice(0, constants_1.DATA_BATCH_SIZE);
            await this.callCallback(data, 'SHUTDOWN_QUEUE');
        }
    }
    startEventBatchPolling() {
        this.pollEventBatchInterval = setInterval(this.sendBatch.bind(this), constants_1.DATA_BATCH_INTERVAL);
    }
    resetEventBatchPolling() {
        this.removeEventBatchPolling('Resetting');
        this.startEventBatchPolling();
    }
    removeEventBatchPolling(tag) {
        if (this.pollEventBatchInterval) {
            log.debug(`${tag} request queue`);
            clearInterval(this.pollEventBatchInterval);
        }
    }
    async sendBatch() {
        const data = this.queue.splice(0, constants_1.DATA_BATCH_SIZE);
        if (data.length === 0) {
            return;
        }
        bstackLogger_1.BStackLogger.debug(`Sending data from request queue. Data length = ${data.length}, Queue length after removal = ${this.queue.length}`);
        await this.callCallback(data, 'INTERVAL_QUEUE');
    }
    shouldProceed() {
        if (this.tearDownInvoked) {
            log.debug('Force request-queue shutdown, as test run event is received after teardown');
            return true;
        }
        return this.queue.length >= constants_1.DATA_BATCH_SIZE;
    }
}
exports.default = RequestQueueHandler;
